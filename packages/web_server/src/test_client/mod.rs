//! Test Client Module - Unified Testing Interface
//!
//! This module provides a unified testing interface that eliminates cfg attributes from test code.
//! It uses a macro-based architecture to generate concrete types at compile time.
//!
//! ## Recommended Usage
//!
//! **Use the simulator backend** for testing:
//! ```toml
//! [dev-dependencies]
//! moosicbox_web_server = { features = ["simulator"] }
//! ```
//!
//! ```rust,no_run
//! use moosicbox_web_server::test_client::{ConcreteTestClient, TestClient, TestResponseExt};
//!
//! fn test_api() {
//!     let client = ConcreteTestClient::new_with_test_routes();
//!     let response = client.get("/test").send().expect("Request should work");
//!     response.assert_status(200);
//! }
//! ```
//!
//! ## Backend Support
//!
//! - **✅ Simulator Backend**: Fully supported, works perfectly with the new architecture
//! - **⚠️  Actix Backend**: Limited support due to thread-safety issues in Actix's `TestServer`
//!
//! ## Architecture
//!
//! The new macro-based architecture eliminates cfg attributes by generating concrete types:
//! - `ConcreteTestClient` - Generated by `impl_test_client!` macro
//! - `ConcreteTestServer` - Generated by `impl_test_client!` macro
//!
//! This follows the same pattern as the `switchy_random` package.

use std::collections::BTreeMap;

#[cfg(feature = "serde")]
use serde::Serialize;

// Core traits and types
mod macros;
mod traits;
mod wrappers;

pub use traits::{GenericTestClient, GenericTestServer};
pub use wrappers::{
    TestClientWrapper, TestClientWrapperError, TestServerWrapper, TestServerWrapperError,
};

// Implementation modules
#[cfg(all(feature = "actix", not(feature = "simulator")))]
pub mod actix_impl;

/// Simulator-based test client implementation
pub mod simulator_impl;

// Common modules
/// Request builder utilities for constructing test requests
pub mod request_builder;
/// Response handling and assertion utilities for test responses
pub mod response;

pub use request_builder::TestRequestBuilder;
pub use response::{TestResponse, TestResponseExt};

/// Unified test client abstraction for both Actix and Simulator backends
pub trait TestClient {
    /// Error type for test client operations
    type Error: std::error::Error + Send + Sync + 'static;

    /// Send a GET request to the specified path
    fn get(&self, path: &str) -> TestRequestBuilder<'_, Self>;

    /// Send a POST request to the specified path
    fn post(&self, path: &str) -> TestRequestBuilder<'_, Self>;

    /// Send a PUT request to the specified path
    fn put(&self, path: &str) -> TestRequestBuilder<'_, Self>;

    /// Send a DELETE request to the specified path
    fn delete(&self, path: &str) -> TestRequestBuilder<'_, Self>;

    /// Execute a request with the given method, path, headers, and body
    ///
    /// # Errors
    /// * Returns error if the request cannot be executed
    /// * Returns error if the response cannot be parsed
    fn execute_request(
        &self,
        method: &str,
        path: &str,
        headers: &BTreeMap<String, String>,
        body: Option<&[u8]>,
    ) -> Result<TestResponse, Self::Error>;
}

/// HTTP method enumeration for test requests
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HttpMethod {
    /// HTTP GET method
    Get,
    /// HTTP POST method
    Post,
    /// HTTP PUT method
    Put,
    /// HTTP DELETE method
    Delete,
    /// HTTP PATCH method
    Patch,
    /// HTTP HEAD method
    Head,
    /// HTTP OPTIONS method
    Options,
}

impl HttpMethod {
    /// Convert HTTP method to its string representation
    #[must_use]
    pub const fn as_str(&self) -> &'static str {
        match self {
            Self::Get => "GET",
            Self::Post => "POST",
            Self::Put => "PUT",
            Self::Delete => "DELETE",
            Self::Patch => "PATCH",
            Self::Head => "HEAD",
            Self::Options => "OPTIONS",
        }
    }
}

/// Request body types for test requests
#[derive(Debug, Clone)]
pub enum RequestBody {
    /// Raw bytes
    Bytes(Vec<u8>),
    /// JSON serializable data
    #[cfg(feature = "serde")]
    Json(serde_json::Value),
    /// Form data
    Form(BTreeMap<String, String>),
    /// Plain text
    Text(String),
}

impl RequestBody {
    /// Convert the request body to bytes and content type
    ///
    /// # Errors
    /// * Returns error if JSON serialization fails
    #[cfg(feature = "serde")]
    pub fn to_bytes_and_content_type(&self) -> Result<(Vec<u8>, String), serde_json::Error> {
        match self {
            Self::Bytes(bytes) => Ok((bytes.clone(), "application/octet-stream".to_string())),
            Self::Json(value) => {
                let bytes = serde_json::to_vec(value)?;
                Ok((bytes, "application/json".to_string()))
            }
            Self::Form(form) => {
                let encoded = form
                    .iter()
                    .map(|(k, v)| format!("{}={}", urlencoding::encode(k), urlencoding::encode(v)))
                    .collect::<Vec<_>>()
                    .join("&");
                Ok((
                    encoded.into_bytes(),
                    "application/x-www-form-urlencoded".to_string(),
                ))
            }
            Self::Text(text) => Ok((text.as_bytes().to_vec(), "text/plain".to_string())),
        }
    }

    /// Convert the request body to bytes and content type (without serde support)
    ///
    /// # Errors
    /// * This version never returns errors since JSON is not supported
    #[cfg(not(feature = "serde"))]
    pub fn to_bytes_and_content_type(&self) -> Result<(Vec<u8>, String), std::convert::Infallible> {
        match self {
            Self::Bytes(bytes) => Ok((bytes.clone(), "application/octet-stream".to_string())),
            Self::Form(form) => {
                let encoded = form
                    .iter()
                    .map(|(k, v)| format!("{}={}", urlencoding::encode(k), urlencoding::encode(v)))
                    .collect::<Vec<_>>()
                    .join("&");
                Ok((
                    encoded.into_bytes(),
                    "application/x-www-form-urlencoded".to_string(),
                ))
            }
            Self::Text(text) => Ok((text.as_bytes().to_vec(), "text/plain".to_string())),
        }
    }

    /// Create a JSON request body from a serializable value
    ///
    /// # Errors
    /// * Returns error if JSON serialization fails
    #[cfg(feature = "serde")]
    pub fn json<T: Serialize>(value: &T) -> Result<Self, serde_json::Error> {
        let json_value = serde_json::to_value(value)?;
        Ok(Self::Json(json_value))
    }

    /// Create a form request body from key-value pairs
    #[must_use]
    pub fn form<K: Into<String>, V: Into<String>>(data: impl IntoIterator<Item = (K, V)>) -> Self {
        let form = data
            .into_iter()
            .map(|(k, v)| (k.into(), v.into()))
            .collect();
        Self::Form(form)
    }
}

// Apply the macro to generate concrete types
// Always use simulator backend for macro-generated types since it's the only backend
// that supports the thread-safe architecture required by the macro system.
// Actix types remain available separately for users who need real HTTP testing.
use macros::impl_test_client;

impl_test_client!(
    simulator_impl::SimulatorTestClient,
    crate::simulator::SimulatorWebServer
);

// Export the concrete types for public use
pub use ConcreteTestClient as TestClientImpl;
pub use ConcreteTestServer as TestServerImpl;
