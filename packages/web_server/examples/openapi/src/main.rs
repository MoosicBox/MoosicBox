//! OpenAPI example for MoosicBox web server.
//!
//! This example demonstrates how to create and serve an OpenAPI specification
//! using the MoosicBox web server framework with utoipa integration.
//!
//! # Features
//!
//! * Creates an OpenAPI specification with example endpoints
//! * Serves the specification through the `/openapi` path
//! * Demonstrates path definition using the `path!` macro
//! * Includes example endpoint with parameters and response documentation

use moosicbox_web_server::{HttpResponse, Scope, path, utoipa};
use utoipa::{OpenApi as _, openapi::OpenApi};

/// Entry point for the OpenAPI example web server.
///
/// Initializes logging, configures CORS, sets up the OpenAPI specification,
/// and starts the web server with example endpoints.
///
/// # Errors
///
/// * Logging initialization fails
/// * Server startup encounters an error
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    moosicbox_logging::init(None, None)?;

    let cors = moosicbox_web_server::cors::Cors::default()
        .allow_any_origin()
        .allow_any_method()
        .allow_any_header()
        .expose_any_header();

    *moosicbox_web_server::openapi::OPENAPI.write().unwrap() = Some(init());

    let server = moosicbox_web_server::WebServerBuilder::new()
        .with_cors(cors)
        .with_scope(moosicbox_web_server::openapi::bind_services(Scope::new(
            "/openapi",
        )))
        // The order matters here. Make sure to add the root scope last
        .with_scope(Scope::new("").get("/example", |req| {
            let path = req.path().to_string();
            let query = req.query_string().to_string();
            Box::pin(async move {
                Ok(HttpResponse::ok()
                    .with_body(format!("hello, world! path={path} query={query}",)))
            })
        }))
        .build();

    server.start().await;

    Ok(())
}

/// Static OpenAPI specification for the example endpoint.
///
/// This lazy-initialized specification defines the `/example` endpoint with:
/// * Tags for API categorization
/// * Path definitions for the example endpoint (from [`GET_EXAMPLE_PATH`])
/// * Component schemas
///
/// The specification is constructed using the utoipa builder pattern and is
/// merged with other API definitions in the [`init`] function.
///
/// # Note
///
/// The `GET_EXAMPLE_PATH` static is generated by the `path!` macro invocation
/// at the end of this file, which creates a `LazyLock<PathItem>` containing
/// the complete path specification for the `/example` endpoint with GET method,
/// parameters, and response definitions.
pub static API: std::sync::LazyLock<utoipa::openapi::OpenApi> = std::sync::LazyLock::new(|| {
    OpenApi::builder()
        .tags(Some([utoipa::openapi::Tag::builder()
            .name("Example")
            .build()]))
        .paths(
            utoipa::openapi::Paths::builder()
                .path("/example", GET_EXAMPLE_PATH.clone())
                .build(),
        )
        .components(Some(utoipa::openapi::Components::builder().build()))
        .build()
});

/// Base OpenAPI documentation structure.
///
/// This empty structure serves as the foundation for the OpenAPI specification,
/// which is extended with custom API definitions through the `nest_api` function
/// in the [`init`] function.
#[derive(utoipa::OpenApi)]
#[openapi()]
struct ApiDoc;

/// Initializes and returns the complete OpenAPI specification.
///
/// This function combines the base API documentation from `ApiDoc` with
/// the custom [`API`] specification, nesting them together to create a
/// complete OpenAPI document.
///
/// # Returns
///
/// Returns a fully constructed [`OpenApi`] specification that includes all
/// endpoint definitions, schemas, and metadata for the example web server.
#[must_use]
pub fn init() -> OpenApi {
    #[allow(unused)]
    fn nest_api(api: OpenApi, path: &str, mut nested: OpenApi) -> OpenApi {
        nested.paths.paths.iter_mut().for_each(|(path, item)| {
            item.options.iter_mut().for_each(|operation| {
                operation.operation_id = Some(path.to_owned());
            });
        });

        api.nest(path, nested)
    }

    nest_api(ApiDoc::openapi(), "", API.clone())
}

path!(
    GET,
    example,
    utoipa::openapi::PathItem::builder()
        .operation(
            HttpMethod::Get,
            Operation::builder()
                .description(Some("description"))
                .tags(Some(["Tag1", "Tag2"]))
                .parameter(
                    Parameter::builder()
                        .name("moosicbox-profile")
                        .parameter_in(ParameterIn::Header)
                        .description(Some("MoosicBox profile"))
                        .required(Required::True)
                        .schema(Some(utoipa::schema!(String))),
                )
                .parameter(
                    Parameter::builder()
                        .name("magicToken")
                        .parameter_in(ParameterIn::Path)
                        .description(Some("The magic token to fetch the credentials for"))
                        .required(Required::True)
                        .schema(Some(utoipa::schema!(String))),
                )
                .responses(
                    Responses::builder()
                        .response(
                            "200",
                            RefOr::T(
                                Response::builder()
                                    .description("The credentials for the magic token")
                                    .content(
                                        "application/json",
                                        Content::builder()
                                            .schema(Some(utoipa::schema!(Value)))
                                            .build(),
                                    )
                                    .build(),
                            ),
                        )
                        .build(),
                ),
        )
        .build()
);

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;
    use utoipa::openapi::{path::*, HttpMethod, PathItem, Paths};

    #[test]
    fn test_init_returns_valid_openapi_spec() {
        let openapi = init();

        // Verify the OpenAPI spec has paths
        assert!(
            !openapi.paths.paths.is_empty(),
            "OpenAPI spec should have paths"
        );
    }

    #[test]
    fn test_init_includes_example_path() {
        let openapi = init();

        // Verify the example path is present
        assert!(
            openapi.paths.paths.contains_key("/example"),
            "OpenAPI spec should contain /example path"
        );
    }

    #[test]
    fn test_init_example_path_has_get_operation() {
        let openapi = init();

        // Get the example path
        let example_path = openapi.paths.paths.get("/example").unwrap();

        // Verify it has a GET operation
        assert!(
            example_path.get.is_some(),
            "/example path should have GET operation"
        );
    }

    #[test]
    fn test_nest_api_preserves_base_paths() {
        // Create a base API with one path
        let base_api = utoipa::openapi::OpenApi::builder()
            .paths(
                Paths::builder()
                    .path(
                        "/base",
                        PathItem::builder()
                            .operation(
                                HttpMethod::Get,
                                Operation::builder().description(Some("base")),
                            )
                            .build(),
                    )
                    .build(),
            )
            .build();

        // Create a nested API with one path
        let nested_api = utoipa::openapi::OpenApi::builder()
            .paths(
                Paths::builder()
                    .path(
                        "/nested",
                        PathItem::builder()
                            .operation(
                                HttpMethod::Get,
                                Operation::builder().description(Some("nested")),
                            )
                            .build(),
                    )
                    .build(),
            )
            .build();

        // Nest the API
        let result = nest_api(base_api, "/api", nested_api);

        // Verify both paths exist
        assert!(
            result.paths.paths.contains_key("/base"),
            "Base path should be preserved"
        );
        assert!(
            result.paths.paths.contains_key("/api/nested"),
            "Nested path should be added with prefix"
        );
    }

    #[test]
    fn test_nest_api_updates_operation_ids() {
        // Create a nested API with operations that have OPTIONS method
        let nested_api = utoipa::openapi::OpenApi::builder()
            .paths(
                Paths::builder()
                    .path(
                        "/test",
                        PathItem::builder()
                            .operation(
                                HttpMethod::Options,
                                Operation::builder()
                                    .operation_id(Some("original_id"))
                                    .build(),
                            )
                            .build(),
                    )
                    .build(),
            )
            .build();

        // Create an empty base API
        let base_api = utoipa::openapi::OpenApi::builder()
            .paths(Paths::builder().build())
            .build();

        // Nest the API
        let result = nest_api(base_api, "/api", nested_api);

        // Verify operation ID was updated to the original path (before nesting)
        let test_path = result.paths.paths.get("/api/test").unwrap();
        if let Some(options) = &test_path.options {
            assert_eq!(
                options.operation_id.as_deref(),
                Some("/test"),
                "Operation ID should be set to the original path key"
            );
        } else {
            panic!("Options operation should exist");
        }
    }

    #[test]
    fn test_nest_api_with_empty_prefix() {
        // Create a nested API
        let nested_api = utoipa::openapi::OpenApi::builder()
            .paths(
                Paths::builder()
                    .path(
                        "/path",
                        PathItem::builder()
                            .operation(
                                HttpMethod::Get,
                                Operation::builder().description(Some("test")),
                            )
                            .build(),
                    )
                    .build(),
            )
            .build();

        // Create an empty base API
        let base_api = utoipa::openapi::OpenApi::builder()
            .paths(Paths::builder().build())
            .build();

        // Nest with empty prefix
        let result = nest_api(base_api, "", nested_api);

        // Verify path exists without prefix
        assert!(
            result.paths.paths.contains_key("/path"),
            "Path should exist without prefix when prefix is empty"
        );
    }

    #[test]
    fn test_api_static_has_example_tag() {
        let api = &*API;

        // Verify tags are present
        assert!(api.tags.is_some(), "API should have tags");

        let tags = api.tags.as_ref().unwrap();
        assert_eq!(tags.len(), 1, "API should have exactly one tag");
        assert_eq!(tags[0].name, "Example", "Tag name should be 'Example'");
    }

    #[test]
    fn test_api_static_has_example_path() {
        let api = &*API;

        // Verify the /example path exists
        assert!(
            api.paths.paths.contains_key("/example"),
            "API should have /example path"
        );
    }

    #[test]
    fn test_api_static_example_path_has_get_method() {
        let api = &*API;

        let example_path = api.paths.paths.get("/example").unwrap();

        // Verify it has a GET operation
        assert!(
            example_path.get.is_some(),
            "/example path should have GET operation"
        );
    }

    #[test]
    fn test_api_static_has_components() {
        let api = &*API;

        // Verify components are present
        assert!(
            api.components.is_some(),
            "API should have components section"
        );
    }

    #[test]
    fn test_get_example_path_static_initialization() {
        // Verify the static is initialized (should not panic)
        let _path = &*GET_EXAMPLE_PATH;

        // Verify it has a GET operation
        assert!(
            _path.get.is_some(),
            "GET_EXAMPLE_PATH should have GET operation"
        );
    }

    /// Helper function to nest API specifications.
    ///
    /// This is a test-accessible version of the nest_api function from main.
    fn nest_api(api: OpenApi, path: &str, mut nested: OpenApi) -> OpenApi {
        nested.paths.paths.iter_mut().for_each(|(path, item)| {
            item.options.iter_mut().for_each(|operation| {
                operation.operation_id = Some(path.to_owned());
            });
        });

        api.nest(path, nested)
    }
}
