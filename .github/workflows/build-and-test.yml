name: Build and Test

on:
    push:
        branches: ['master', 'edge']
        paths:
            - .github/workflows/build-and-test.yml
            - packages/**
            - '**/*.toml'
            - '**/Cargo.lock'
            - free_disk_space.sh
            - '!packages/marketing_site/*.ts'
            - '!packages/marketing_site/*.json'
            - '!packages/marketing_site/pnpm-lock.yaml'
            - '!packages/marketing_site/*.mjs'
            - '!packages/marketing_site/*.js'
            - '!packages/marketing_site/*.md'
            - '!packages/marketing_site/.prettierignore'
            - '!packages/marketing_site/hyperchad/**'
            - '!packages/marketing_site/infra/**'
            - '!packages/hyperchad/renderer/vanilla_js/web/**'
            - '!**/*.nix'
            - '!**/Dockerfile'
            - '!**/*.Dockerfile'
            - '!**/*.dockerignore'
    pull_request:
        branches: ['master', 'edge']
    schedule:
        - cron: '0 7 * * *'
    workflow_dispatch:
        inputs:
            edge:
                description: 'Edge'
                required: false
                default: 'false'
env:
    CARGO_TERM_COLOR: always

jobs:
    cargo-deny:
        continue-on-error: true
        runs-on: ubuntu-latest

        strategy:
            matrix:
                checks:
                    - bans
                    - sources
                    - licenses

        steps:
            - uses: actions/checkout@v4

            - uses: dtolnay/rust-toolchain@stable

            - name: cargo-deny check ${{ matrix.checks }}
              uses: EmbarkStudios/cargo-deny-action@v2
              with:
                  command: check ${{ matrix.checks }}
                  arguments: --all-features

    coverage:
        continue-on-error: true
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v4

            - uses: dtolnay/rust-toolchain@stable
              with:
                  toolchain: nightly
                  components: rustfmt,llvm-tools-preview

            - name: cargo install cargo-llvm-cov
              uses: taiki-e/install-action@cargo-llvm-cov

            - name: Get dependencies
              id: dependencies
              run: |
                  DEPENDENCIES="$(cargo run -p clippier dependencies . --os ubuntu)"
                  echo "Using dependencies:"
                  echo "$DEPENDENCIES"
                  echo 'dependencies<<EOF' >> $GITHUB_OUTPUT
                  echo "$DEPENDENCIES" >> $GITHUB_OUTPUT
                  echo 'EOF' >> $GITHUB_OUTPUT

            - name: Get environment
              id: environment
              run: |
                  ENVIRONMENT="$(cargo run -p clippier environment . --os ubuntu -o json | jq -cr 'join(" ")')"
                  echo "Using environment:"
                  echo "$ENVIRONMENT"
                  echo 'environment<<EOF' >> $GITHUB_OUTPUT
                  echo "$ENVIRONMENT" >> $GITHUB_OUTPUT
                  echo 'EOF' >> $GITHUB_OUTPUT

            - name: Get ci_steps
              id: ci_steps
              run: |
                  CI_STEPS="$(cargo run -p clippier ci-steps . --os ubuntu -o json | jq -cr 'join(" ")')"
                  echo "Using ci_steps:"
                  echo "$CI_STEPS"
                  echo 'ci_steps<<EOF' >> $GITHUB_OUTPUT
                  echo "$CI_STEPS" >> $GITHUB_OUTPUT
                  echo 'EOF' >> $GITHUB_OUTPUT

            - name: Setup cmake
              uses: jwlawson/actions-setup-cmake@v2
              with:
                  cmake-version: '3.x'

            - name: Setup CI
              if: ${{ steps.ci_steps.outputs.ci_steps }}
              run: ${{ steps.ci_steps.outputs.ci_steps }}

            - name: Install dependencies
              if: ${{ steps.dependencies.outputs.dependencies }}
              shell: bash
              run: ${{ steps.dependencies.outputs.dependencies }}

            - name: cargo llvm-cov
              run: ${{ steps.environment.outputs.environment }} cargo +nightly llvm-cov --locked --workspace --lcov --output-path lcov.info

            - name: Upload coverage reports to Codecov
              uses: codecov/codecov-action@v5
              with:
                  token: ${{ secrets.CODECOV_TOKEN }}
                  slug: MoosicBox/MoosicBox
                  fail_ci_if_error: true

    determine-affected-packages:
        name: Determine affected packages
        runs-on: ubuntu-latest
        outputs:
            matrix: ${{ steps.set-matrix.outputs.matrix }}
            has-changes: ${{ steps.set-matrix.outputs.has-changes }}
            has-tauri-changes: ${{ steps.check-tauri-changes.outputs.has-tauri-changes }}
        steps:
            - uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - uses: dtolnay/rust-toolchain@stable

            - name: Get changed files
              id: changed-files
              run: |
                  if [ "${{ github.event_name }}" == "pull_request" ]; then
                      # For pull requests, get changed files between base and head
                      echo "Pull request: comparing ${{ github.event.pull_request.base.sha }} to ${{ github.event.pull_request.head.sha }}"
                      CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
                  elif [ "${{ github.event_name }}" == "push" ]; then
                      # For pushes, get changed files between the before and after commits
                      # This handles multiple commits being pushed at once
                      BEFORE_SHA="${{ github.event.before }}"
                      AFTER_SHA="${{ github.event.after }}"
                      FORCED="${{ github.event.forced }}"

                      echo "Push event: before=$BEFORE_SHA after=$AFTER_SHA forced=$FORCED"

                      # If this is the first push to a new branch, github.event.before will be all zeros
                      if [ "$BEFORE_SHA" == "0000000000000000000000000000000000000000" ]; then
                          # For new branches, compare against the default branch
                          DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 2>/dev/null || echo "master")
                          echo "New branch detected, comparing against origin/$DEFAULT_BRANCH"
                          if ! git diff --name-only origin/$DEFAULT_BRANCH...$AFTER_SHA; then
                              echo "Error: Could not compare against origin/$DEFAULT_BRANCH...$AFTER_SHA"
                              echo "This likely means the git history is incomplete or the branch doesn't exist"
                              exit 1
                          fi
                          CHANGED_FILES=$(git diff --name-only origin/$DEFAULT_BRANCH...$AFTER_SHA)
                      elif [ "$FORCED" == "true" ] || ! git diff --name-only $BEFORE_SHA..$AFTER_SHA >/dev/null 2>&1; then
                          # Handle force pushes or invalidated before commits
                          if [ "$FORCED" == "true" ]; then
                              echo "Force push detected - before commit $BEFORE_SHA is no longer valid"
                          else
                              echo "Before commit $BEFORE_SHA is not available - likely due to force push"
                          fi

                          # Try to find a valid commit from recent successful workflow runs
                          echo "Searching through recent successful workflow runs..."
                          FOUND_VALID_COMMIT=false
                          LAST_SUCCESS_SHA=""

                          # Get up to 10 recent successful workflow runs
                          WORKFLOW_RUNS=$(curl -s \
                              -H "Authorization: Bearer ${{ github.token }}" \
                              -H "Accept: application/vnd.github.v3+json" \
                              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build-and-test.yml/runs?branch=${{ github.ref_name }}&status=success&per_page=10")

                          # Walk through each run until we find a valid commit
                          for i in $(seq 0 9); do
                              RUN_SHA=$(echo "$WORKFLOW_RUNS" | jq -r ".workflow_runs[$i].head_sha // empty")
                              if [ -z "$RUN_SHA" ] || [ "$RUN_SHA" == "null" ] || [ "$RUN_SHA" == "empty" ]; then
                                  echo "No more workflow runs to check (checked $((i)) runs)"
                                  break
                              fi

                              if [ "$RUN_SHA" == "$AFTER_SHA" ]; then
                                  echo "Skipping current commit $RUN_SHA"
                                  continue
                              fi

                              echo "Checking if commit $RUN_SHA is available in git history..."
                              if git cat-file -e $RUN_SHA 2>/dev/null; then
                                  echo "Found valid commit from workflow run: $RUN_SHA"
                                  LAST_SUCCESS_SHA="$RUN_SHA"
                                  FOUND_VALID_COMMIT=true
                                  break
                              else
                                  echo "Commit $RUN_SHA not available in git history, trying next..."
                              fi
                          done

                          if [ "$FOUND_VALID_COMMIT" == "true" ]; then
                              echo "Comparing against last valid workflow run: $LAST_SUCCESS_SHA..$AFTER_SHA"
                              CHANGED_FILES=$(git diff --name-only $LAST_SUCCESS_SHA..$AFTER_SHA)
                          else
                              echo "Could not find any valid commits from recent workflow runs, using branch comparison fallback"
                              DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 2>/dev/null || echo "master")
                              if [ "${{ github.ref_name }}" == "$DEFAULT_BRANCH" ]; then
                                  echo "Force push on default branch - assuming all packages affected"
                                  CHANGED_FILES="packages/"
                              else
                                  echo "Comparing against origin/$DEFAULT_BRANCH"
                                  CHANGED_FILES=$(git diff --name-only origin/$DEFAULT_BRANCH...$AFTER_SHA)
                              fi
                          fi
                      else
                          # Normal push: compare the range of commits
                          echo "Comparing commit range: $BEFORE_SHA..$AFTER_SHA"
                          CHANGED_FILES=$(git diff --name-only $BEFORE_SHA..$AFTER_SHA)
                      fi
                  else
                      # For workflow_dispatch or schedule, assume all packages are affected
                      echo "Workflow dispatch or schedule: assuming all packages affected"
                      CHANGED_FILES="packages/"
                  fi

                  # Convert to comma-separated for clippier
                  CHANGED_FILES_CSV=$(echo "$CHANGED_FILES" | tr '\n' ',' | sed 's/,$//')

                  echo "changed-files=$CHANGED_FILES_CSV" >> $GITHUB_OUTPUT
                  echo "Changed files:"
                  echo "$CHANGED_FILES"

            - name: Generate matrix for affected packages
              id: set-matrix
              run: |
                  CHANGED_FILES="${{ steps.changed-files.outputs.changed-files }}"

                  # Build the clippier command conditionally
                  if [[ -n "$CHANGED_FILES" ]]; then
                      echo "Building matrix for affected packages only"
                      CLIPPIER_CMD="cargo run -p clippier features . --changed-files \"$CHANGED_FILES\" --chunked 15 --max-parallel 256 -o json --spread"
                  else
                      echo "Building matrix for all packages (scheduled run or no changed files detected)"
                      CLIPPIER_CMD="cargo run -p clippier features . --chunked 15 --max-parallel 256 -o json --spread"
                  fi

                  echo "Running: $CLIPPIER_CMD"

                  MATRIX=$(
                      eval "$CLIPPIER_CMD" \
                          | jq -rc \
                              '[
                                  .[]
                                  | {
                                      "name": (.name | sub("^(moosicbox|switchy|hyperchad)_"; "")),
                                      "path": (.path),
                                      "features": (.features),
                                      "requiredFeatures": (if .requiredFeatures != null then .requiredFeatures | join(",") else null end),
                                      "os": (.os + "-latest"),
                                      "dependencies": (.dependencies),
                                      "toolchains": (.toolchains),
                                      "ciSteps": (.ciSteps),
                                      "ciToolchains": (.ciToolchains),
                                      "env": (if .env != null then .env | gsub("\n";" ") else null end),
                                      "nightly": (.nightly)
                                  }
                                  | del(.. | nulls)
                              ]'
                  )

                  echo "Matrix length: $(echo "$MATRIX" | jq length)"
                  echo "Using matrix:"
                  echo "$MATRIX" | jq

                  # Check if matrix is empty
                  if [[ "$(echo "$MATRIX" | jq length)" -eq 0 ]]; then
                      echo "has-changes=false" >> $GITHUB_OUTPUT
                      echo "matrix=[]" >> $GITHUB_OUTPUT
                  else
                      echo "has-changes=true" >> $GITHUB_OUTPUT
                      echo "matrix=$(echo "$MATRIX" | jq -c .)" >> $GITHUB_OUTPUT
                  fi

            - name: Check Tauri-related changes
              id: check-tauri-changes
              run: |
                  CHANGED_FILES="${{ steps.changed-files.outputs.changed-files }}"

                  if [[ -n "$CHANGED_FILES" ]]; then
                      echo "Checking if changes affect the Tauri app..."

                      # First check if app-website files changed (these don't affect Rust packages but do affect Tauri)
                      WEBSITE_AFFECTED=false
                      if echo "$CHANGED_FILES" | grep -q "app-website/"; then
                          echo "App website files changed - Tauri release needed"
                          WEBSITE_AFFECTED=true
                      fi

                      # Use clippier to check if the moosicbox_app package is affected by the changes
                      echo "Checking if moosicbox_app package is affected by changes..."
                      TAURI_CHECK_RESULT=$(cargo run -p clippier affected-packages . --changed-files "$CHANGED_FILES" --target-package moosicbox_app --output json)

                      TAURI_AFFECTED=$(echo "$TAURI_CHECK_RESULT" | jq -r '.affected')

                      if [[ "$TAURI_AFFECTED" == "true" ]]; then
                          echo "✅ moosicbox_app package is affected by changes"

                          # Show which packages were affected that led to this determination
                          AFFECTED_PACKAGES=$(echo "$TAURI_CHECK_RESULT" | jq -r '.all_affected[]')
                          echo "All affected packages:"
                          echo "$AFFECTED_PACKAGES" | sed 's/^/  - /'
                      else
                          echo "❌ moosicbox_app package is not affected by changes"
                          TAURI_AFFECTED=false
                      fi

                      # Final determination
                      if [[ "$WEBSITE_AFFECTED" == "true" || "$TAURI_AFFECTED" == "true" ]]; then
                          echo "has-tauri-changes=true" >> $GITHUB_OUTPUT
                          echo "✅ Tauri-related changes detected - Tauri release will be triggered"
                      else
                          echo "has-tauri-changes=false" >> $GITHUB_OUTPUT
                          echo "❌ No Tauri-related changes detected - Tauri release will be skipped"
                      fi
                  else
                      # For scheduled runs or when no specific files are detected, assume Tauri is affected
                      echo "No specific changed files detected (scheduled run or workflow_dispatch) - assuming Tauri is affected"
                      echo "has-tauri-changes=true" >> $GITHUB_OUTPUT
                      echo "✅ Tauri-related changes assumed for scheduled run"
                  fi

    build-cargo-machete:
        name: Build cargo-machete

        strategy:
            fail-fast: true

            matrix:
                os: ['macos-latest', 'ubuntu-latest', 'windows-latest']

        runs-on: ${{ matrix.os }}

        steps:
            - uses: dtolnay/rust-toolchain@stable

            - name: Install cargo-machete
              shell: bash
              run: |
                  cargo install cargo-machete

            - uses: actions/upload-artifact@master
              if: ${{ matrix.os == 'macos-latest' }}
              with:
                  name: cargo-machete-macos
                  path: ~/.cargo/bin/cargo-machete

            - uses: actions/upload-artifact@master
              if: ${{ matrix.os == 'ubuntu-latest' }}
              with:
                  name: cargo-machete-ubuntu
                  path: ~/.cargo/bin/cargo-machete

            - uses: actions/upload-artifact@master
              if: ${{ matrix.os == 'windows-latest' }}
              with:
                  name: cargo-machete.exe
                  path: ~/.cargo/bin/cargo-machete.exe

    build:
        runs-on: ${{ matrix.package.os }}

        needs: [determine-affected-packages, build-cargo-machete]

        if: ${{ needs.determine-affected-packages.outputs.has-changes == 'true' }}

        strategy:
            fail-fast: false

            matrix:
                package: ${{ fromJson(needs.determine-affected-packages.outputs.matrix) }}

        steps:
            - uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Enable patches
              if: ${{ github.event_name == 'schedule' || github.event.inputs.edge == 'true' }}
              run: |
                  git config user.name "MoosicBoxBot"
                  git config user.email "MoosicBoxBot@gmail.com"
                  git checkout edge
                  git rebase master

            - uses: dtolnay/rust-toolchain@stable
              with:
                  toolchain: ${{ matrix.package.nightly && 'nightly' || 'stable' }}
                  components: rustfmt, clippy

            - name: Install winget
              if: ${{ matrix.package.os == 'windows-latest' && contains(matrix.package.dependencies, 'winget') }}
              uses: BSteffaniak/install-winget@v1

            - name: Setup CI
              if: ${{ matrix.package.ciSteps }}
              run: ${{ matrix.package.ciSteps }}

            - uses: pnpm/action-setup@v3
              if: ${{ contains(matrix.package.toolchains, 'pnpm') || contains(matrix.package.ciToolchains, 'pnpm') }}
              name: Install pnpm
              with:
                  version: latest
                  run_install: false

            - uses: actions/setup-node@v4
              if: ${{ contains(matrix.package.toolchains, 'node') || contains(matrix.package.ciToolchains, 'node') }}
              name: Install node
              with:
                  node-version: latest

            - name: Setup cmake
              uses: jwlawson/actions-setup-cmake@v2
              with:
                  cmake-version: '3.x'

            - name: Install dependencies
              if: ${{ matrix.package.dependencies }}
              shell: bash
              run: ${{ matrix.package.dependencies }}

            - name: Clippy ${{ matrix.package.name }}
              shell: bash
              run: |
                  (cd ${{ matrix.package.path }}; \
                      while read -r feature; do \
                          command="${{ matrix.package.env }} cargo${{ matrix.package.nightly && ' +nightly' || '' }} clippy ${{ runner.debug && '-vv ' }}--no-default-features --features="fail-on-warnings${{ matrix.package.requiredFeatures && format(',{0}', matrix.package.requiredFeatures) || '' }},$feature" ${{ matrix.package.cargo }}"
                          # Trim whitespace
                          command=$(echo "$command" | xargs)
                          echo "RUNNING \`$command\`"
                          if ${{ matrix.package.env }} cargo${{ matrix.package.nightly && ' +nightly' || '' }} clippy \
                              ${{ runner.debug && '-vv' }} \
                              --no-default-features \
                              --features="fail-on-warnings${{ matrix.package.requiredFeatures && format(',{0}', matrix.package.requiredFeatures) || '' }},$feature" ${{ matrix.package.cargo }}; then
                              echo "SUCCESS \`$command\`";
                          else
                              >&2 echo "FAILED \`$command\`";
                              >&2 echo "COMMAND: (cd ${{ matrix.package.path }}; $command)";
                              return 1
                          fi
                      done <<<"$(echo '${{ toJson(matrix.package.features) }}' | jq -r '.[]')")

            - name: Run ${{ matrix.package.name }} tests
              shell: bash
              run: |
                  (cd ${{ matrix.package.path }}; \
                      while read -r feature; do \
                          command="${{ matrix.package.env }} cargo${{ matrix.package.nightly && ' +nightly' || '' }} test --no-default-features --features="fail-on-warnings${{ matrix.package.requiredFeatures && format(',{0}', matrix.package.requiredFeatures) || '' }},$feature" ${{ matrix.package.cargo }}"
                          # Trim whitespace
                          command=$(echo "$command" | xargs)
                          echo "RUNNING \`$command\`"
                          if ${{ matrix.package.env }} cargo${{ matrix.package.nightly && ' +nightly' || '' }} test \
                              ${{ runner.debug && '-vv' }} \
                              --no-default-features \
                              --features="fail-on-warnings${{ matrix.package.requiredFeatures && format(',{0}', matrix.package.requiredFeatures) || '' }},$feature" ${{ matrix.package.cargo }}; then
                              echo "SUCCESS \`$command\`";
                          else
                              >&2 echo "FAILED \`$command\`";
                              >&2 echo "COMMAND: (cd ${{ matrix.package.path }}; $command)";
                              return 1
                          fi
                      done <<<"$(echo '${{ toJson(matrix.package.features) }}' | jq -r '.[]')")

            - name: Format ${{ matrix.package.name }}
              shell: bash
              run: |
                  (cd ${{ matrix.package.path }}; ${{ matrix.package.env }} cargo${{ matrix.package.nightly && ' +nightly' || '' }} ${{ runner.debug && '-vv' }} fmt --all -- --check)

            - uses: actions/download-artifact@master
              if: ${{ matrix.package.os == 'macos-latest' }}
              with:
                  name: cargo-machete-macos
                  path: ~/.cargo/bin

            - uses: actions/download-artifact@master
              if: ${{ matrix.package.os == 'ubuntu-latest' }}
              with:
                  name: cargo-machete-ubuntu
                  path: ~/.cargo/bin

            - uses: actions/download-artifact@master
              if: ${{ matrix.package.os == 'windows-latest' }}
              with:
                  name: cargo-machete.exe
                  path: ~/.cargo/bin

            - name: Make cargo-machete executable
              if: ${{ matrix.package.os == 'macos-latest' }}
              shell: bash
              run: chmod +x ~/.cargo/bin/cargo-machete

            - name: Make cargo-machete executable
              if: ${{ matrix.package.os == 'ubuntu-latest' }}
              shell: bash
              run: chmod +x ~/.cargo/bin/cargo-machete

            - name: Make cargo-machete executable
              if: ${{ matrix.package.os == 'windows-latest' }}
              shell: bash
              run: chmod +x ~/.cargo/bin/cargo-machete.exe

            - name: Validate ${{ matrix.package.name }} dependencies (machete)
              if: ${{ matrix.package.os == 'macos-latest' }}
              shell: bash
              run: |
                  ${{ matrix.package.env }} ~/.cargo/bin/cargo-machete --with-metadata ${{ matrix.package.path }}

            - name: Validate ${{ matrix.package.name }} dependencies (machete)
              if: ${{ matrix.package.os == 'ubuntu-latest' }}
              shell: bash
              run: |
                  ${{ matrix.package.env }} ~/.cargo/bin/cargo-machete --with-metadata ${{ matrix.package.path }}

            - name: Validate ${{ matrix.package.name }} dependencies (machete)
              if: ${{ matrix.package.os == 'windows-latest' }}
              shell: bash
              run: |
                  ${{ matrix.package.env }} ~/.cargo/bin/cargo-machete.exe --with-metadata ${{ matrix.package.path }}

    create-tauri-app-release:
        if: ${{ github.event_name != 'schedule' && !github.event.inputs.edge && needs.determine-affected-packages.outputs.has-tauri-changes == 'true' }}

        runs-on: ubuntu-latest

        needs: [determine-affected-packages, build]

        steps:
            - uses: actions/checkout@v4
              with:
                  token: ${{ secrets.WORKFLOW_MANAGEMENT_TOKEN }}
                  path: MoosicBox

            - name: Get release hash
              id: release_hash
              run: |
                  HASH="$(git -C MoosicBox rev-parse --verify HEAD | head -c 10)"
                  echo "hash: $HASH"
                  echo "hash=$HASH" >> $GITHUB_OUTPUT

            - name: Check tag exists for SHA
              id: check_exists
              working-directory: MoosicBox
              run: |
                  git fetch --unshallow --tags
                  if [[ -n $(git show-ref --tags -d) ]]; then
                      git show-ref --tags -d

                      if [[ $(git show-ref --tags -d | grep "${{ github.sha }}") =~ "master-${{ steps.release_hash.outputs.hash }}" ]]; then
                          echo "exists=true" >> $GITHUB_OUTPUT
                          echo "exists"
                      else
                          echo "exists=false" >> $GITHUB_OUTPUT
                          echo "does not exist"
                      fi
                  fi

            - uses: BSteffaniak/delete-older-releases@master
              if: ${{ steps.check_exists.outputs.exists != 'true' }}
              with:
                  keep_latest: 2
                  delete_tag_pattern: ^master-[0-9a-f]{10,10}$
                  regex: true
              env:
                  GITHUB_TOKEN: ${{ secrets.WORKFLOW_MANAGEMENT_TOKEN }}

            - name: Create and push tag
              if: ${{ steps.check_exists.outputs.exists != 'true' }}
              working-directory: MoosicBox
              run: |
                  git tag master-${{ steps.release_hash.outputs.hash }}
                  git push origin master-${{ steps.release_hash.outputs.hash }}
