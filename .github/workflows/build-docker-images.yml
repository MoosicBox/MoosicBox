name: Build Docker Images

on:
    push:
        branches: ['master', 'edge']
        paths:
            - .github/workflows/build-docker-images.yml
            - packages/**
            - '**/*.toml'
            - '**/Cargo.lock'
            - free_disk_space.sh
            - '!packages/marketing_site/*.ts'
            - '!packages/marketing_site/*.json'
            - '!packages/marketing_site/pnpm-lock.yaml'
            - '!packages/marketing_site/*.mjs'
            - '!packages/marketing_site/*.js'
            - '!packages/marketing_site/*.md'
            - '!packages/marketing_site/.prettierignore'
            - '!packages/marketing_site/hyperchad/**'
            - '!packages/marketing_site/infra/**'
            - '!packages/hyperchad/renderer/vanilla_js/web/**'
            - '!**/*.nix'
            - '!**/Dockerfile'
            - '!**/*.Dockerfile'
            - '!**/*.dockerignore'
    pull_request:
        branches: ['master', 'edge']
    workflow_dispatch:
        inputs:
            edge:
                description: 'Edge'
                required: false
                type: boolean
                default: false
env:
    CARGO_TERM_COLOR: always

jobs:
    determine-affected-packages:
        runs-on: ubuntu-latest
        outputs:
            matrix: ${{ steps.set-matrix.outputs.matrix }}
            has-changes: ${{ steps.set-matrix.outputs.has-changes }}
        steps:
            - uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Get changed files
              id: changed-files
              run: |
                  if [ "${{ github.event_name }}" == "pull_request" ]; then
                      # For pull requests, get changed files between base and head
                      echo "Pull request: comparing ${{ github.event.pull_request.base.sha }} to ${{ github.event.pull_request.head.sha }}"
                      CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
                  elif [ "${{ github.event_name }}" == "push" ]; then
                      # For pushes, get changed files between the before and after commits
                      # This handles multiple commits being pushed at once
                      BEFORE_SHA="${{ github.event.before }}"
                      AFTER_SHA="${{ github.event.after }}"
                      FORCED="${{ github.event.forced }}"

                      echo "Push event: before=$BEFORE_SHA after=$AFTER_SHA forced=$FORCED"

                      # If this is the first push to a new branch, github.event.before will be all zeros
                      if [ "$BEFORE_SHA" == "0000000000000000000000000000000000000000" ]; then
                          # For new branches, compare against the default branch
                          DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 2>/dev/null || echo "master")
                          echo "New branch detected, comparing against origin/$DEFAULT_BRANCH"
                          if ! git diff --name-only origin/$DEFAULT_BRANCH...$AFTER_SHA; then
                              echo "Error: Could not compare against origin/$DEFAULT_BRANCH...$AFTER_SHA"
                              echo "This likely means the git history is incomplete or the branch doesn't exist"
                              exit 1
                          fi
                          CHANGED_FILES=$(git diff --name-only origin/$DEFAULT_BRANCH...$AFTER_SHA)
                      elif [ "$FORCED" == "true" ] || ! git diff --name-only $BEFORE_SHA..$AFTER_SHA >/dev/null 2>&1; then
                          # Handle force pushes or invalidated before commits
                          if [ "$FORCED" == "true" ]; then
                              echo "Force push detected - before commit $BEFORE_SHA is no longer valid"
                          else
                              echo "Before commit $BEFORE_SHA is not available - likely due to force push"
                          fi

                          # Try to find a valid commit from recent successful workflow runs
                          echo "Searching through recent successful workflow runs..."
                          FOUND_VALID_COMMIT=false
                          LAST_SUCCESS_SHA=""

                          # Get up to 10 recent successful workflow runs
                          WORKFLOW_RUNS=$(curl -s \
                              -H "Authorization: Bearer ${{ github.token }}" \
                              -H "Accept: application/vnd.github.v3+json" \
                              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build-docker-images.yml/runs?branch=${{ github.ref_name }}&status=success&per_page=10")

                          # Walk through each run until we find a valid commit
                          for i in $(seq 0 9); do
                              RUN_SHA=$(echo "$WORKFLOW_RUNS" | jq -r ".workflow_runs[$i].head_sha // empty")
                              if [ -z "$RUN_SHA" ] || [ "$RUN_SHA" == "null" ] || [ "$RUN_SHA" == "empty" ]; then
                                  echo "No more workflow runs to check (checked $((i)) runs)"
                                  break
                              fi

                              if [ "$RUN_SHA" == "$AFTER_SHA" ]; then
                                  echo "Skipping current commit $RUN_SHA"
                                  continue
                              fi

                              echo "Checking if commit $RUN_SHA is available in git history..."
                              if git cat-file -e $RUN_SHA 2>/dev/null; then
                                  echo "Found valid commit from workflow run: $RUN_SHA"
                                  LAST_SUCCESS_SHA="$RUN_SHA"
                                  FOUND_VALID_COMMIT=true
                                  break
                              else
                                  echo "Commit $RUN_SHA not available in git history, trying next..."
                              fi
                          done

                          if [ "$FOUND_VALID_COMMIT" == "true" ]; then
                              echo "Comparing against last valid workflow run: $LAST_SUCCESS_SHA..$AFTER_SHA"
                              CHANGED_FILES=$(git diff --name-only $LAST_SUCCESS_SHA..$AFTER_SHA)
                          else
                              echo "Could not find any valid commits from recent workflow runs, using branch comparison fallback"
                              DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 2>/dev/null || echo "master")
                              if [ "${{ github.ref_name }}" == "$DEFAULT_BRANCH" ]; then
                                  echo "Force push on default branch - assuming all packages affected"
                                  CHANGED_FILES="packages/"
                              else
                                  echo "Comparing against origin/$DEFAULT_BRANCH"
                                  CHANGED_FILES=$(git diff --name-only origin/$DEFAULT_BRANCH...$AFTER_SHA)
                              fi
                          fi
                      else
                          # Normal push: compare the range of commits
                          echo "Comparing commit range: $BEFORE_SHA..$AFTER_SHA"
                          CHANGED_FILES=$(git diff --name-only $BEFORE_SHA..$AFTER_SHA)
                      fi
                  else
                      # For workflow_dispatch, assume all packages are affected
                      echo "Workflow dispatch: assuming all packages affected"
                      CHANGED_FILES="packages/"
                  fi
                  echo "changed_files<<EOF" >> $GITHUB_OUTPUT
                  echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                  echo "Changed files:"
                  echo "$CHANGED_FILES"

            - name: Install Rust
              uses: dtolnay/rust-toolchain@stable

            - name: Build clippier
              run: |
                  cd packages/clippier
                  cargo build --release

            - name: Determine affected packages
              id: affected-packages
              run: |
                  # Convert changed files to comma-separated list for clippier
                  CHANGED_FILES="${{ steps.changed-files.outputs.changed_files }}"
                  CHANGED_FILES_CSV=$(echo "$CHANGED_FILES" | tr '\n' ',' | sed 's/,$//')

                  echo "Checking affected packages for files: $CHANGED_FILES_CSV"

                  # Get affected packages using clippier
                  AFFECTED_PACKAGES=$(./target/release/clippier affected-packages . --changed-files "$CHANGED_FILES_CSV" --output json)
                  echo "affected_packages=$AFFECTED_PACKAGES" >> $GITHUB_OUTPUT
                  echo "Affected packages: $AFFECTED_PACKAGES"

            - name: Set matrix
              id: set-matrix
              run: |
                  # Parse affected packages and create matrix
                  AFFECTED_PACKAGES='${{ steps.affected-packages.outputs.affected_packages }}'

                  # Define the packages that have Docker images (mapping from package name to docker info)
                  DOCKER_PACKAGES='{"moosicbox_server": {"name": "server", "dockerfile": "packages/server/Server.Dockerfile"}, "moosicbox_tunnel_server": {"name": "tunnel_server", "dockerfile": "packages/tunnel_server/TunnelServer.Dockerfile"}, "moosicbox_load_balancer": {"name": "load_balancer", "dockerfile": "packages/load_balancer/LoadBalancer.Dockerfile"}}'

                  # Extract affected package names from the JSON
                  AFFECTED_PACKAGE_NAMES=$(echo "$AFFECTED_PACKAGES" | jq -r '.affected_packages[]')

                  # Build the matrix with packages that both have Docker images and are affected
                  MATRIX_PROJECTS="[]"
                  for pkg in $AFFECTED_PACKAGE_NAMES; do
                      DOCKER_INFO=$(echo "$DOCKER_PACKAGES" | jq -r ".\"$pkg\" // empty")
                      if [ -n "$DOCKER_INFO" ] && [ "$DOCKER_INFO" != "null" ]; then
                          MATRIX_PROJECTS=$(echo "$MATRIX_PROJECTS" | jq ". + [$DOCKER_INFO]")
                      fi
                  done

                  # Check if any packages are affected
                  if [ $(echo "$MATRIX_PROJECTS" | jq 'length') -eq 0 ]; then
                      echo "No Docker packages are affected by the changes"
                      # Create a dummy matrix entry to satisfy GitHub Actions matrix requirements
                      MATRIX='{"include": [{"name": "no-changes", "dockerfile": "dummy"}]}'
                      echo "has-changes=false" >> $GITHUB_OUTPUT
                  else
                      MATRIX="{\"include\": $MATRIX_PROJECTS}"
                      echo "has-changes=true" >> $GITHUB_OUTPUT
                  fi

                  # Ensure the JSON is properly formatted and compact
                  MATRIX=$(echo "$MATRIX" | jq -c .)

                  echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
                  echo "Generated matrix: $MATRIX"

    build:
        needs: determine-affected-packages
        if: ${{ needs.determine-affected-packages.outputs.has-changes == 'true' }}
        strategy:
            fail-fast: false
            matrix: ${{ fromJson(needs.determine-affected-packages.outputs.matrix) }}

        runs-on: ubuntu-latest

        steps:
            - uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Enable patches
              if: ${{ github.event_name == 'schedule' || github.event.inputs.edge == true }}
              run: |
                  git config user.name "MoosicBoxBot"
                  git config user.email "MoosicBoxBot@gmail.com"
                  git checkout edge
                  git rebase master

            - name: Generate Dockerfile
              shell: bash
              run: |
                  ./generate-dockerfiles.sh ${{ matrix.name }}

            - name: Build Dockerfile
              shell: bash
              run: |
                  docker build . -f ${{ matrix.dockerfile }}
