name: Build Docker Images

on:
    push:
        branches: ['master', 'edge']
        paths:
            - .github/workflows/build-docker-images.yml
            - packages/**
            - '**/*.toml'
            - '**/Cargo.lock'
            - free_disk_space.sh
            - '!packages/marketing_site/*.ts'
            - '!packages/marketing_site/*.json'
            - '!packages/marketing_site/pnpm-lock.yaml'
            - '!packages/marketing_site/*.mjs'
            - '!packages/marketing_site/*.js'
            - '!packages/marketing_site/*.md'
            - '!packages/marketing_site/.prettierignore'
            - '!packages/marketing_site/hyperchad/**'
            - '!packages/marketing_site/infra/**'
            - '!packages/hyperchad/renderer/vanilla_js/web/**'
            - '!**/*.nix'
            - '!**/Dockerfile'
            - '!**/*.Dockerfile'
            - '!**/*.dockerignore'
    pull_request:
        branches: ['master', 'edge']
    workflow_dispatch:
        inputs:
            edge:
                description: 'Edge'
                required: false
                type: boolean
                default: false
env:
    CARGO_TERM_COLOR: always

jobs:
    determine-affected-packages:
        runs-on: ubuntu-latest
        outputs:
            matrix: ${{ steps.analyze-changes.outputs.matrix }}
            has-changes: ${{ steps.analyze-changes.outputs.has-changes }}
        steps:
            - uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Install Rust
              uses: dtolnay/rust-toolchain@stable

            - name: Build clippier with git-diff support
              run: |
                  cd packages/clippier
                  cargo build --release --features git-diff

            - name: Analyze changes and generate matrix
              id: analyze-changes
              run: |
                  echo "ðŸ” Starting comprehensive change analysis..."

                  # === GIT REFERENCE RESOLUTION ===
                  if [ "${{ github.event_name }}" == "pull_request" ]; then
                      echo "ðŸ“‹ Pull request: comparing ${{ github.event.pull_request.base.sha }} to ${{ github.event.pull_request.head.sha }}"
                      GIT_BASE="${{ github.event.pull_request.base.sha }}"
                      GIT_HEAD="${{ github.event.pull_request.head.sha }}"
                      CHANGED_FILES=$(git diff --name-only $GIT_BASE $GIT_HEAD)
                  elif [ "${{ github.event_name }}" == "push" ]; then
                      BEFORE_SHA="${{ github.event.before }}"
                      AFTER_SHA="${{ github.event.after }}"
                      FORCED="${{ github.event.forced }}"
                      echo "ðŸ“¤ Push event: before=$BEFORE_SHA after=$AFTER_SHA forced=$FORCED"

                      if [ "$BEFORE_SHA" == "0000000000000000000000000000000000000000" ]; then
                          echo "ðŸŒŸ New branch detected, comparing against default branch"
                          DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 2>/dev/null || echo "master")
                          if ! git diff --name-only origin/$DEFAULT_BRANCH...$AFTER_SHA >/dev/null 2>&1; then
                              echo "âŒ Error: Could not compare against origin/$DEFAULT_BRANCH...$AFTER_SHA"
                              exit 1
                          fi
                          GIT_BASE="origin/$DEFAULT_BRANCH"
                          GIT_HEAD="$AFTER_SHA"
                          CHANGED_FILES=$(git diff --name-only $GIT_BASE...$GIT_HEAD)
                      elif [ "$FORCED" == "true" ] || ! git diff --name-only $BEFORE_SHA..$AFTER_SHA >/dev/null 2>&1; then
                          if [ "$FORCED" == "true" ]; then
                              echo "âš¡ Force push detected - before commit $BEFORE_SHA is no longer valid"
                          else
                              echo "â“ Before commit $BEFORE_SHA is not available - likely due to force push"
                          fi

                          echo "ðŸ” Searching through recent successful workflow runs..."
                          FOUND_VALID_COMMIT=false
                          LAST_SUCCESS_SHA=""

                          WORKFLOW_RUNS=$(curl -s \
                              -H "Authorization: Bearer ${{ github.token }}" \
                              -H "Accept: application/vnd.github.v3+json" \
                              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build-docker-images.yml/runs?branch=${{ github.ref_name }}&status=success&per_page=10")

                          for i in $(seq 0 9); do
                              RUN_SHA=$(echo "$WORKFLOW_RUNS" | jq -r ".workflow_runs[$i].head_sha // empty")
                              if [ -z "$RUN_SHA" ] || [ "$RUN_SHA" == "null" ] || [ "$RUN_SHA" == "empty" ]; then
                                  echo "No more workflow runs to check (checked $((i)) runs)"
                                  break
                              fi

                              if [ "$RUN_SHA" == "$AFTER_SHA" ]; then
                                  echo "Skipping current commit $RUN_SHA"
                                  continue
                              fi

                              if git cat-file -e $RUN_SHA 2>/dev/null; then
                                  echo "âœ… Found valid commit from workflow run: $RUN_SHA"
                                  LAST_SUCCESS_SHA="$RUN_SHA"
                                  FOUND_VALID_COMMIT=true
                                  break
                              else
                                  echo "âŒ Commit $RUN_SHA not available in git history, trying next..."
                              fi
                          done

                          if [ "$FOUND_VALID_COMMIT" == "true" ]; then
                              echo "ðŸ“Š Comparing against last valid workflow run: $LAST_SUCCESS_SHA..$AFTER_SHA"
                              GIT_BASE="$LAST_SUCCESS_SHA"
                              GIT_HEAD="$AFTER_SHA"
                              CHANGED_FILES=$(git diff --name-only $GIT_BASE..$GIT_HEAD)
                          else
                              echo "âš ï¸ Could not find valid commits, using branch comparison fallback"
                              DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 2>/dev/null || echo "master")
                              if [ "${{ github.ref_name }}" == "$DEFAULT_BRANCH" ]; then
                                  echo "ðŸ”„ Force push on default branch - assuming all packages affected"
                                  GIT_BASE=""
                                  GIT_HEAD=""
                                  CHANGED_FILES="packages/"
                              else
                                  echo "ðŸŒ¿ Comparing against origin/$DEFAULT_BRANCH"
                                  GIT_BASE="origin/$DEFAULT_BRANCH"
                                  GIT_HEAD="$AFTER_SHA"
                                  CHANGED_FILES=$(git diff --name-only $GIT_BASE...$GIT_HEAD)
                              fi
                          fi
                      else
                          echo "ðŸ“ˆ Normal push: comparing commit range $BEFORE_SHA..$AFTER_SHA"
                          GIT_BASE="$BEFORE_SHA"
                          GIT_HEAD="$AFTER_SHA"
                          CHANGED_FILES=$(git diff --name-only $GIT_BASE..$GIT_HEAD)
                      fi
                  else
                      echo "ðŸŽ¯ Workflow dispatch: assuming all packages affected"
                      GIT_BASE=""
                      GIT_HEAD=""
                      CHANGED_FILES="packages/"
                  fi

                  echo "ðŸ“„ Changed files:"
                  echo "$CHANGED_FILES"

                  # === CHANGE ANALYSIS ===
                  CHANGED_FILES_CSV=$(echo "$CHANGED_FILES" | tr '\n' ',' | sed 's/,$//')

                  # Check if Cargo.toml or Cargo.lock files changed
                  CARGO_CHANGED=false
                  if echo "$CHANGED_FILES" | grep -qE "(Cargo\.(toml|lock))"; then
                      CARGO_CHANGED=true
                      echo "ðŸ”§ Cargo files detected in changes"
                  fi

                  # Determine analysis method and get affected packages
                  if [ "$CARGO_CHANGED" == "true" ] && [ -n "$GIT_BASE" ] && [ -n "$GIT_HEAD" ]; then
                      echo "ðŸ§  Using hybrid analysis (smart external deps + file-based changes)"
                      echo "   Git range: $GIT_BASE..$GIT_HEAD"

                      # Use smart analysis with git diff for external dependencies
                      AFFECTED_PACKAGES=$(./target/release/clippier affected-packages . \
                          --changed-files "$CHANGED_FILES_CSV" \
                          --git-base "$GIT_BASE" \
                          --git-head "$GIT_HEAD" \
                          --output json)

                      ANALYSIS_METHOD="hybrid (external deps + file changes)"
                  else
                      echo "ðŸ“ Using file-based analysis"

                      # Use regular file-based analysis
                      AFFECTED_PACKAGES=$(./target/release/clippier affected-packages . \
                          --changed-files "$CHANGED_FILES_CSV" \
                          --output json)

                      ANALYSIS_METHOD="file-based"
                  fi

                  echo "ðŸ“¦ Analysis result: $AFFECTED_PACKAGES"

                  # === MATRIX GENERATION ===
                  # Define the packages that have Docker images (mapping from package name to docker info)
                  DOCKER_PACKAGES='{"moosicbox_server": {"name": "server", "dockerfile": "packages/server/Server.Dockerfile"}, "moosicbox_tunnel_server": {"name": "tunnel_server", "dockerfile": "packages/tunnel_server/TunnelServer.Dockerfile"}, "moosicbox_load_balancer": {"name": "load_balancer", "dockerfile": "packages/load_balancer/LoadBalancer.Dockerfile"}}'

                  # Extract affected package names from the JSON
                  AFFECTED_PACKAGE_NAMES=$(echo "$AFFECTED_PACKAGES" | jq -r '.affected_packages[]' 2>/dev/null || echo "")

                  # Build the matrix with packages that both have Docker images and are affected
                  MATRIX_PROJECTS="[]"
                  AFFECTED_DOCKER_PACKAGES=""
                  for pkg in $AFFECTED_PACKAGE_NAMES; do
                      DOCKER_INFO=$(echo "$DOCKER_PACKAGES" | jq -r ".\"$pkg\" // empty")
                      if [ -n "$DOCKER_INFO" ] && [ "$DOCKER_INFO" != "null" ] && [ "$DOCKER_INFO" != "empty" ]; then
                          MATRIX_PROJECTS=$(echo "$MATRIX_PROJECTS" | jq ". + [$DOCKER_INFO]")
                          if [ -z "$AFFECTED_DOCKER_PACKAGES" ]; then
                              AFFECTED_DOCKER_PACKAGES="$pkg"
                          else
                              AFFECTED_DOCKER_PACKAGES="$AFFECTED_DOCKER_PACKAGES, $pkg"
                          fi
                      fi
                  done

                  # Check if any Docker packages are affected
                  DOCKER_COUNT=$(echo "$MATRIX_PROJECTS" | jq 'length')
                  if [ "$DOCKER_COUNT" -eq 0 ]; then
                      if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
                          echo "ðŸŽ¯ Workflow dispatch: building all Docker packages"
                          # For manual dispatch, build all Docker packages
                          MATRIX_PROJECTS=$(echo "$DOCKER_PACKAGES" | jq '[.[] | {name: .name, dockerfile: .dockerfile}]')
                          MATRIX="{\"include\": $MATRIX_PROJECTS}"
                          echo "has-changes=true" >> $GITHUB_OUTPUT
                          AFFECTED_DOCKER_PACKAGES="all (manual dispatch)"
                      else
                          echo "âœ¨ No Docker packages are affected by the changes"
                          MATRIX='{"include": []}'
                          echo "has-changes=false" >> $GITHUB_OUTPUT
                          AFFECTED_DOCKER_PACKAGES="none"
                      fi
                  else
                      MATRIX="{\"include\": $MATRIX_PROJECTS}"
                      echo "has-changes=true" >> $GITHUB_OUTPUT
                  fi

                  # Ensure the JSON is properly formatted and compact
                  MATRIX=$(echo "$MATRIX" | jq -c .)

                  echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

                  # === SUMMARY ===
                  echo ""
                  echo "ðŸ“Š === DOCKER BUILD ANALYSIS SUMMARY ==="
                  echo "ðŸ” Analysis method: $ANALYSIS_METHOD"
                  echo "ðŸ³ Docker packages to build: $AFFECTED_DOCKER_PACKAGES"
                  echo "ðŸ“ˆ Matrix size: $DOCKER_COUNT packages"
                  echo "ðŸš€ Generated matrix: $MATRIX"
                  echo "=============================================="

            - name: Smart CI Summary
              if: always()
              run: |
                  echo "## ðŸ§  Smart CI Analysis Summary" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY

                  HAS_CHANGES="${{ steps.analyze-changes.outputs.has-changes }}"
                  EVENT_NAME="${{ github.event_name }}"

                  # Show event type
                  case "$EVENT_NAME" in
                      "workflow_dispatch")
                          echo "ðŸš€ **Trigger**: Manual workflow dispatch" >> $GITHUB_STEP_SUMMARY
                          ;;
                      "schedule")
                          echo "â° **Trigger**: Scheduled run" >> $GITHUB_STEP_SUMMARY
                          ;;
                      "push")
                          echo "ðŸ“¤ **Trigger**: Push to ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
                          ;;
                      "pull_request")
                          echo "ðŸ”€ **Trigger**: Pull request" >> $GITHUB_STEP_SUMMARY
                          ;;
                  esac
                  echo "" >> $GITHUB_STEP_SUMMARY

                  # The analyze-changes step will have logged whether smart or file-based analysis was used
                  # We can detect this from the step logs, but for the summary we'll check if analysis was done
                  if [[ "$HAS_CHANGES" == "true" ]]; then
                      MATRIX_LENGTH=$(echo '${{ steps.analyze-changes.outputs.matrix }}' | jq length)
                      PACKAGES_LENGTH=$(echo '${{ steps.analyze-changes.outputs.matrix }}' | jq '[.[].name] | unique [] | length')
                      echo "ðŸ“Š **Build Matrix**: $MATRIX_LENGTH jobs for $PACKAGES_LENGTH packages will be built/tested" >> $GITHUB_STEP_SUMMARY
                      echo "" >> $GITHUB_STEP_SUMMARY
                      echo "**Affected packages:**" >> $GITHUB_STEP_SUMMARY
                      echo '${{ steps.analyze-changes.outputs.matrix }}' | jq -r '[.[].name] | unique []' | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
                  else
                      if [[ "$EVENT_NAME" == "workflow_dispatch" || "$EVENT_NAME" == "schedule" ]]; then
                          echo "âš ï¸ **No Packages**: Matrix generation may have failed for manual/scheduled run" >> $GITHUB_STEP_SUMMARY
                      else
                          echo "ðŸŽ‰ **No Changes**: No packages affected - builds will be skipped!" >> $GITHUB_STEP_SUMMARY
                      fi
                  fi

    build:
        needs: determine-affected-packages
        if: ${{ needs.determine-affected-packages.outputs.has-changes == 'true' }}
        strategy:
            fail-fast: false
            matrix: ${{ fromJson(needs.determine-affected-packages.outputs.matrix) }}

        runs-on: ubuntu-latest

        steps:
            - uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Enable patches
              if: ${{ github.event_name == 'schedule' || github.event.inputs.edge == true }}
              run: |
                  git config user.name "MoosicBoxBot"
                  git config user.email "MoosicBoxBot@gmail.com"
                  git checkout edge
                  git rebase master

            - name: Generate Dockerfile
              shell: bash
              run: |
                  ./generate-dockerfiles.sh ${{ matrix.name }}

            - name: Build Dockerfile
              shell: bash
              run: |
                  docker build . -f ${{ matrix.dockerfile }}
