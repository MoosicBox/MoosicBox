name: "Claude Checker"
description: "Generic Claude-based checker with orchestration features"
author: "MoosicBox"

inputs:
    # === Authentication (Required) ===
    github_token:
        description: "GitHub token with write permissions"
        required: true
    claude_token:
        description: "Claude Code OAuth token"
        required: true

    # === Prompt Template (One Required) ===
    prompt_template:
        description: "Built-in template: readme, rustdoc, examples, issue, pr, code-review"
        required: false
    prompt_template_file:
        description: "Path to custom template file"
        required: false
    prompt_template_text:
        description: "Inline template text"
        required: false

    # === Template Variables ===
    template_vars:
        description: "YAML/JSON object of template variables"
        required: false
        default: "{}"

    # === Behavior ===
    branch_name:
        description: "Branch name (overrides template default)"
        required: false
    commit_message:
        description: "Commit message (supports variables)"
        required: false
    auto_commit:
        description: "Automatically commit changes"
        required: false
        default: "true"

    # === Stream Watcher (Optional) ===
    enable_stream_watcher:
        description: "Enable live progress updates"
        required: false
        default: "false"
    stream_watcher_script:
        description: "Path to stream watcher script"
        required: false
        default: ".github/scripts/stream-watcher.sh"
    stream_comment_id:
        description: "Comment ID for live updates"
        required: false
    stream_comment_type:
        description: "Comment type: issue, pr_issue_comment, pr_review_comment"
        required: false

    # === Execution Details (Optional) ===
    enable_execution_details:
        description: "Append execution details to comment"
        required: false
        default: "false"
    execution_details_script:
        description: "Path to execution details script"
        required: false
        default: ".github/scripts/format-execution-details.sh"
    acknowledgment_comment_id:
        description: "Comment ID to append details to"
        required: false

    # === Co-Author Attribution (Optional) ===
    enable_coauthor_attribution:
        description: "Add co-author to commits"
        required: false
        default: "false"
    coauthor_login:
        description: "Co-author GitHub username (auto-detected)"
        required: false
    coauthor_id:
        description: "Co-author GitHub ID (auto-detected)"
        required: false
    coauthor_email:
        description: "Co-author email (auto-detected)"
        required: false
    trigger_comment_url:
        description: "Trigger URL (auto-detected)"
        required: false

    # === Resilient Push (Optional) ===
    enable_resilient_push:
        description: "Enable push with retry/rebase"
        required: false
        default: "true"
    push_max_retries:
        description: "Max push retry attempts"
        required: false
        default: "5"
    push_timeout_seconds:
        description: "Push timeout in seconds"
        required: false
        default: "30"
    fallback_branch_prefix:
        description: "Prefix for fallback branch"
        required: false
        default: "claude-fallback"

    # === Commit Message Extraction ===
    extract_commit_message:
        description: "Extract commit description from output"
        required: false
        default: "true"
    commit_message_start_marker:
        description: "Start marker for extraction"
        required: false
        default: "COMMIT_MESSAGE_START"
    commit_message_end_marker:
        description: "End marker for extraction"
        required: false
        default: "COMMIT_MESSAGE_END"

    # === Claude Config ===
    model:
        description: "Claude model"
        required: false
    max_tokens:
        description: "Max tokens"
        required: false
    max_turns:
        description: "Max turns"
        required: false
    claude_args:
        description: "Additional Claude args"
        required: false

    # === Advanced ===
    working_directory:
        description: "Working directory"
        required: false
        default: "."

outputs:
    has_changes:
        description: "true if changes were made"
        value: ${{ steps.detect_changes.outputs.has_changes }}
    files_changed:
        description: "Space-separated changed files"
        value: ${{ steps.detect_changes.outputs.files_changed }}
    branch_name:
        description: "Branch used"
        value: ${{ steps.setup_branch.outputs.branch_name }}
    execution_file:
        description: "Execution details file path"
        value: ${{ steps.claude.outputs.execution_file }}
    resolved_template_vars:
        description: "Resolved variables JSON"
        value: ${{ steps.resolve_template.outputs.resolved_vars }}

    # Push outputs
    push_status:
        description: "Push status: success, no_changes, fallback, failed"
        value: ${{ steps.push_changes.outputs.push_status }}
    push_branch:
        description: "Branch pushed to"
        value: ${{ steps.push_changes.outputs.push_branch }}
    fallback_branch:
        description: "Fallback branch (if created)"
        value: ${{ steps.push_changes.outputs.fallback_branch }}
    compare_url:
        description: "Compare URL for fallback"
        value: ${{ steps.push_changes.outputs.compare_url }}

    commit_created:
        description: "true if commit was created"
        value: ${{ steps.commit_changes.outputs.commit_created }}

runs:
    using: "composite"
    steps:
        - name: Validate inputs
          shell: bash
          run: |
              if [ -z "${{ inputs.prompt_template }}" ] && \
                 [ -z "${{ inputs.prompt_template_file }}" ] && \
                 [ -z "${{ inputs.prompt_template_text }}" ]; then
                echo "‚ùå Error: One of prompt_template, prompt_template_file, or prompt_template_text must be provided"
                exit 1
              fi
              echo "‚úÖ Input validation passed"

        - name: Setup Node.js for template processing
          uses: actions/setup-node@v4
          with:
              node-version: "20"

        - name: Install dependencies
          shell: bash
          working-directory: ${{ github.action_path }}
          run: |
              if [ ! -d "node_modules" ]; then
                npm install
              fi

        - name: Resolve template and variables
          id: resolve_template
          shell: bash
          working-directory: ${{ github.action_path }}
          env:
              PROMPT_TEMPLATE: ${{ inputs.prompt_template }}
              PROMPT_TEMPLATE_FILE: ${{ inputs.prompt_template_file }}
              PROMPT_TEMPLATE_TEXT: ${{ inputs.prompt_template_text }}
              TEMPLATE_VARS: ${{ inputs.template_vars }}
              GITHUB_CONTEXT: ${{ toJSON(github) }}
          run: |
              node src/resolve-template.js

        - name: Setup branch
          id: setup_branch
          shell: bash
          env:
              RESOLVED_BRANCH_NAME: ${{ steps.resolve_template.outputs.branch_name }}
              INPUT_BRANCH_NAME: ${{ inputs.branch_name }}
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              # Use explicit input branch, or resolved from template, or generate default
              if [ -n "$INPUT_BRANCH_NAME" ]; then
                BRANCH_NAME="$INPUT_BRANCH_NAME"
              elif [ -n "$RESOLVED_BRANCH_NAME" ]; then
                BRANCH_NAME="$RESOLVED_BRANCH_NAME"
              else
                BRANCH_NAME="claude-updates-${{ github.run_id }}"
              fi

              echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

              # Check if branch exists
              if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
                echo "üìç Branch $BRANCH_NAME already exists, checking out"
                git fetch origin "$BRANCH_NAME"
                git checkout "$BRANCH_NAME"
              else
                echo "üå± Creating new branch: $BRANCH_NAME"
                git checkout -b "$BRANCH_NAME"
              fi

        - name: Setup git configuration
          shell: bash
          run: |
              git config user.name "MoosicBoxBot"
              git config user.email "MoosicBoxBot@gmail.com"

        - name: Check stream watcher prerequisites
          if: inputs.enable_stream_watcher == 'true'
          shell: bash
          run: |
              # Verify inotify-tools is installed
              if ! command -v inotifywait &> /dev/null; then
                echo "‚ö†Ô∏è WARNING: inotify-tools not installed. Stream watcher will be disabled."
                echo "Install with: sudo apt-get install -y inotify-tools"
                echo "stream_watcher_enabled=false" >> $GITHUB_ENV
              else
                echo "‚úÖ inotify-tools found"
                echo "stream_watcher_enabled=true" >> $GITHUB_ENV
              fi

              # Verify stream watcher script exists
              if [ ! -f "${{ inputs.stream_watcher_script }}" ]; then
                echo "‚ö†Ô∏è WARNING: Stream watcher script not found: ${{ inputs.stream_watcher_script }}"
                echo "stream_watcher_enabled=false" >> $GITHUB_ENV
              fi

              # Verify comment ID provided
              if [ -z "${{ inputs.stream_comment_id }}" ]; then
                echo "‚ö†Ô∏è WARNING: stream_comment_id not provided"
                echo "stream_watcher_enabled=false" >> $GITHUB_ENV
              fi

        - name: Start stream watcher
          if: inputs.enable_stream_watcher == 'true' && env.stream_watcher_enabled == 'true'
          shell: bash
          run: |
              STREAM_FILE="${{ runner.temp }}/claude-stream.jsonl"

              ${{ inputs.stream_watcher_script }} \
                "$STREAM_FILE" \
                "${{ github.repository }}" \
                "${{ inputs.github_token }}" \
                "${{ inputs.stream_comment_id }}" \
                "${{ inputs.stream_comment_type }}" \
                > /tmp/stream-watcher.log 2>&1 &

              WATCHER_PID=$!
              echo $WATCHER_PID > /tmp/stream_watcher_pid.txt
              echo "üîÑ Stream watcher started (PID: $WATCHER_PID)"
              echo "üìã Stream file: $STREAM_FILE"

        - name: Run Claude Code
          id: claude
          uses: BSteffaniak/claude-code-action@dev
          with:
              claude_code_oauth_token: ${{ inputs.claude_token }}
              stream_output_file: ${{ inputs.enable_stream_watcher == 'true' && env.stream_watcher_enabled == 'true' && format('{0}/claude-stream.jsonl', runner.temp) || '' }}
              prompt: ${{ steps.resolve_template.outputs.rendered_prompt }}
              claude_args: ${{ inputs.claude_args }}

        - name: Stop stream watcher
          if: always() && inputs.enable_stream_watcher == 'true' && env.stream_watcher_enabled == 'true'
          shell: bash
          run: |
              if [ -f /tmp/stream_watcher_pid.txt ]; then
                WATCHER_PID=$(cat /tmp/stream_watcher_pid.txt)
                
                echo "‚è≥ Waiting for stream watcher (PID: $WATCHER_PID) to complete..."
                
                # Graceful shutdown (30 seconds)
                for i in {1..30}; do
                  if ! kill -0 $WATCHER_PID 2>/dev/null; then
                    echo "‚úÖ Stream watcher completed"
                    break
                  fi
                  sleep 1
                done
                
                # Force shutdown if still running
                if kill -0 $WATCHER_PID 2>/dev/null; then
                  echo "‚ö†Ô∏è Stream watcher still running, sending SIGTERM..."
                  kill -TERM $WATCHER_PID 2>/dev/null || true
                  sleep 2
                  
                  if kill -0 $WATCHER_PID 2>/dev/null; then
                    echo "‚ö†Ô∏è Forcing stream watcher to stop..."
                    kill -9 $WATCHER_PID 2>/dev/null || true
                  fi
                fi
                
                # Show logs if available
                if [ -f /tmp/stream-watcher.log ]; then
                  echo ""
                  echo "üìã Stream watcher logs:"
                  cat /tmp/stream-watcher.log
                fi
              fi

        - name: Detect changes
          id: detect_changes
          shell: bash
          run: |
              if [ -n "$(git status --porcelain)" ] || [ "$(git rev-list --count origin/${{ steps.setup_branch.outputs.branch_name }}..HEAD 2>/dev/null || echo 0)" != "0" ]; then
                echo "has_changes=true" >> $GITHUB_OUTPUT
                echo "files_changed=$(git diff --name-only HEAD 2>/dev/null | tr '\n' ' ')" >> $GITHUB_OUTPUT
                echo "‚úÖ Changes detected"
              else
                echo "has_changes=false" >> $GITHUB_OUTPUT
                echo "files_changed=" >> $GITHUB_OUTPUT
                echo "üì≠ No changes detected"
              fi

        - name: Commit changes
          id: commit_changes
          if: inputs.auto_commit == 'true' && steps.detect_changes.outputs.has_changes == 'true'
          shell: bash
          run: |
              # Check for uncommitted changes
              if [ -z "$(git status --porcelain)" ]; then
                echo "üì≠ No uncommitted changes"
                echo "commit_created=false" >> $GITHUB_OUTPUT
                exit 0
              fi

              echo "üìù Changes detected, preparing commit..."

              # Remove output.txt if it exists (from claude-code-action)
              rm -f output.txt

              git add -A

              # Get base commit message from template or input
              BASE_COMMIT_MSG="${{ inputs.commit_message }}"
              if [ -z "$BASE_COMMIT_MSG" ]; then
                BASE_COMMIT_MSG="${{ steps.resolve_template.outputs.commit_message }}"
              fi
              if [ -z "$BASE_COMMIT_MSG" ]; then
                BASE_COMMIT_MSG="chore: update via Claude checker"
              fi

              # Extract detailed description from Claude output if enabled
              COMMIT_DESC=""
              if [ "${{ inputs.extract_commit_message }}" = "true" ] && [ -f output.txt ]; then
                echo "üìã Extracting commit description from Claude output..."
                
                # Try JSONL format first (from claude-code-action)
                COMMIT_DESC=$(grep "${{ inputs.commit_message_start_marker }}" output.txt 2>/dev/null | head -1 | \
                  jq -r '.message.content[0].text | 
                  split("${{ inputs.commit_message_start_marker }}\n")[1] | 
                  split("\n${{ inputs.commit_message_end_marker }}")[0]' 2>/dev/null || echo "")
                
                # Try plain text format
                if [ -z "$COMMIT_DESC" ]; then
                  COMMIT_DESC=$(sed -n '/${{ inputs.commit_message_start_marker }}/,/${{ inputs.commit_message_end_marker }}/p' output.txt 2>/dev/null | \
                    sed '1d;$d' || echo "")
                fi
              fi

              # Create commit
              if [ -n "$COMMIT_DESC" ] && [ "$COMMIT_DESC" != "null" ]; then
                echo "üìã Using detailed commit description:"
                echo "$COMMIT_DESC"
                git commit -m "$BASE_COMMIT_MSG" -m "$COMMIT_DESC"
              else
                echo "üìã Using base commit message: $BASE_COMMIT_MSG"
                git commit -m "$BASE_COMMIT_MSG"
              fi

              echo "commit_created=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Commit created"

        - name: Add co-author attribution to commits
          if: always() && inputs.enable_coauthor_attribution == 'true' && steps.commit_changes.outputs.commit_created == 'true'
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              # Count commits to process
              DEFAULT_BRANCH="${{ github.event.repository.default_branch || 'main' }}"
              COMMITS_AHEAD=$(git rev-list --count origin/$DEFAULT_BRANCH..HEAD 2>/dev/null || echo "0")

              if [ "$COMMITS_AHEAD" = "0" ]; then
                echo "üì≠ No commits to add co-author to"
                exit 0
              fi

              echo "üìä Found $COMMITS_AHEAD commit(s) to process"

              # Determine co-author from inputs or event context
              COAUTHOR_LOGIN="${{ inputs.coauthor_login }}"
              COAUTHOR_ID="${{ inputs.coauthor_id }}"
              COAUTHOR_EMAIL="${{ inputs.coauthor_email }}"

              if [ -z "$COAUTHOR_LOGIN" ]; then
                COAUTHOR_LOGIN="${{ github.event.comment.user.login || github.event.review.user.login || github.event.issue.user.login || github.actor }}"
                COAUTHOR_ID="${{ github.event.comment.user.id || github.event.review.user.id || github.event.issue.user.id }}"
              fi

              if [ -z "$COAUTHOR_LOGIN" ]; then
                echo "‚ö†Ô∏è Could not determine co-author, skipping"
                exit 0
              fi

              # Try to find real email if not provided
              if [ -z "$COAUTHOR_EMAIL" ]; then
                echo "üîç Searching for email for $COAUTHOR_LOGIN..."
                
                # Try user profile API
                COAUTHOR_EMAIL=$(gh api "/users/$COAUTHOR_LOGIN" --jq '.email // empty' 2>/dev/null || echo "")
                
                # Try recent commits
                if [ -z "$COAUTHOR_EMAIL" ]; then
                  COAUTHOR_EMAIL=$(gh api "/users/$COAUTHOR_LOGIN/events/public" --jq '
                    [.[] | select(.type == "PushEvent") | .payload.commits[]? | .author.email]
                    | map(select(. != null and . != ""))
                    | first // empty
                  ' 2>/dev/null || echo "")
                fi
                
                # Fallback to noreply
                if [ -z "$COAUTHOR_EMAIL" ] || [ "$COAUTHOR_EMAIL" = "null" ]; then
                  COAUTHOR_EMAIL="${COAUTHOR_ID}+${COAUTHOR_LOGIN}@users.noreply.github.com"
                fi
              fi

              COAUTHOR_LINE="Co-authored-by: ${COAUTHOR_LOGIN} <${COAUTHOR_EMAIL}>"
              echo "üë• Co-author: $COAUTHOR_LINE"

              # Determine trigger URL
              COMMENT_URL="${{ inputs.trigger_comment_url }}"
              if [ -z "$COMMENT_URL" ]; then
                COMMENT_URL="${{ github.event.comment.html_url || github.event.review.html_url || github.event.issue.html_url }}"
              fi

              if [ -n "$COMMENT_URL" ]; then
                echo "üîó Trigger URL: $COMMENT_URL"
              fi

              # Create rebase script to amend all commits
              cat > /tmp/add_coauthor.sh << 'SCRIPT'
              #!/bin/bash
              MSG=$(git log -1 --pretty=%B)
              MODIFIED=false

              # Add trigger URL if not present
              if [ -n "$COMMENT_URL" ] && ! echo "$MSG" | grep -qF "Triggered-by:"; then
                if echo "$MSG" | tail -1 | grep -q '^$'; then
                  MSG=$(printf '%sTriggered-by: %s\n' "$MSG" "$COMMENT_URL")
                else
                  MSG=$(printf '%s\n\nTriggered-by: %s\n' "$MSG" "$COMMENT_URL")
                fi
                MODIFIED=true
              fi

              # Add co-author if not present
              if ! echo "$MSG" | grep -qF "$COAUTHOR_LINE"; then
                if echo "$MSG" | tail -1 | grep -q '^$'; then
                  MSG=$(printf '%s%s\n' "$MSG" "$COAUTHOR_LINE")
                else
                  MSG=$(printf '%s\n\n%s\n' "$MSG" "$COAUTHOR_LINE")
                fi
                MODIFIED=true
              fi

              # Amend if modified
              if [ "$MODIFIED" = "true" ]; then
                printf '%s' "$MSG" | git commit --amend -F -
              fi
              SCRIPT

              chmod +x /tmp/add_coauthor.sh
              export COAUTHOR_LINE
              export COMMENT_URL

              # Rebase and amend all commits
              BASE_COMMIT=$(git merge-base HEAD origin/$DEFAULT_BRANCH 2>/dev/null || echo "origin/$DEFAULT_BRANCH")

              if GIT_SEQUENCE_EDITOR=true git rebase -i --exec "/tmp/add_coauthor.sh" $BASE_COMMIT 2>&1; then
                echo "‚úÖ Added co-author to $COMMITS_AHEAD commit(s)"
              else
                echo "‚ö†Ô∏è Failed to add co-author, continuing anyway..."
                git rebase --abort 2>/dev/null || true
              fi

        - name: Push changes with resilient retry
          id: push_changes
          if: always() && inputs.enable_resilient_push == 'true'
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              git remote set-url origin "https://x-access-token:${{ inputs.github_token }}@github.com/${{ github.repository }}.git"

              TARGET_BRANCH="${{ steps.setup_branch.outputs.branch_name }}"
              DEFAULT_BRANCH="${{ github.event.repository.default_branch || 'main' }}"

              # Check if there are commits to push
              COMMITS_AHEAD=$(git rev-list --count origin/$TARGET_BRANCH..HEAD 2>/dev/null || echo "0")

              if [ "$COMMITS_AHEAD" = "0" ]; then
                echo "üì≠ No commits to push"
                echo "push_status=no_changes" >> $GITHUB_OUTPUT
                exit 0
              fi

              echo "üìä Found $COMMITS_AHEAD commit(s) to push to $TARGET_BRANCH"

              # Resilient push with retry logic
              MAX_RETRIES=${{ inputs.push_max_retries }}
              RETRY_COUNT=0
              BACKOFF=1
              MAX_TIME=${{ inputs.push_timeout_seconds }}
              START_TIME=$(date +%s)

              while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                ELAPSED=$(($(date +%s) - START_TIME))
                if [ $ELAPSED -gt $MAX_TIME ]; then
                  echo "‚è±Ô∏è Timeout reached after ${ELAPSED}s"
                  break
                fi
                
                echo "üì§ Push attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
                
                if git push origin "$TARGET_BRANCH" 2>&1; then
                  echo "‚úÖ Successfully pushed to $TARGET_BRANCH"
                  echo "push_status=success" >> $GITHUB_OUTPUT
                  echo "push_branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT
                  exit 0
                fi
                
                echo "‚ö†Ô∏è Push rejected, attempting rebase..."
                
                # Fetch latest changes
                git fetch origin "$TARGET_BRANCH"
                
                # Attempt rebase
                if git rebase "origin/$TARGET_BRANCH" 2>&1; then
                  echo "‚úÖ Rebase successful, retrying push..."
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                  sleep $BACKOFF
                  BACKOFF=$((BACKOFF * 2))
                  continue
                else
                  # Check for conflicts
                  if git status | grep -E "both modified|both added|both deleted|conflict" >/dev/null 2>&1; then
                    echo "üö´ CONFLICTS DETECTED during rebase"
                    git rebase --abort 2>/dev/null || true
                    break
                  else
                    echo "‚ö†Ô∏è Rebase failed for non-conflict reason"
                    git rebase --abort 2>/dev/null || true
                    break
                  fi
                fi
              done

              # Create fallback branch if push failed
              echo "üîÄ Creating fallback branch..."
              TIMESTAMP=$(date +%s)
              FALLBACK_BRANCH="${{ inputs.fallback_branch_prefix }}-${{ github.run_id }}-${TIMESTAMP}"

              # Ensure clean state
              git rebase --abort 2>/dev/null || true

              # Create fallback branch from current commits
              git checkout -B "$FALLBACK_BRANCH"

              echo "üì§ Pushing to fallback branch: $FALLBACK_BRANCH"
              if git push origin "$FALLBACK_BRANCH" 2>&1; then
                echo "‚úÖ Successfully pushed to fallback branch"
                echo "push_status=fallback" >> $GITHUB_OUTPUT
                echo "push_branch=$FALLBACK_BRANCH" >> $GITHUB_OUTPUT
                echo "fallback_branch=$FALLBACK_BRANCH" >> $GITHUB_OUTPUT
                echo "original_branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT
                echo "commits_count=$COMMITS_AHEAD" >> $GITHUB_OUTPUT
                
                # Create compare URL
                COMPARE_URL="${{ github.server_url }}/${{ github.repository }}/compare/${TARGET_BRANCH}...${FALLBACK_BRANCH}"
                echo "compare_url=$COMPARE_URL" >> $GITHUB_OUTPUT
                
                echo ""
                echo "‚ö†Ô∏è FALLBACK BRANCH CREATED"
                echo "Compare: $COMPARE_URL"
                
                exit 0
              else
                echo "‚ùå Failed to push even to fallback branch"
                echo "push_status=failed" >> $GITHUB_OUTPUT
                exit 1
              fi

        - name: Format and append execution details
          if: always() && inputs.enable_execution_details == 'true' && steps.claude.outputs.execution_file != ''
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              EXEC_FILE="${{ steps.claude.outputs.execution_file }}"

              if [ ! -f "$EXEC_FILE" ] || [ ! -s "$EXEC_FILE" ]; then
                echo "‚ö†Ô∏è Execution file not found or empty"
                exit 0
              fi

              echo "üìä Execution file found: $EXEC_FILE"

              # Check if formatting script exists
              if [ ! -f "${{ inputs.execution_details_script }}" ]; then
                echo "‚ö†Ô∏è Execution details script not found: ${{ inputs.execution_details_script }}"
                exit 0
              fi

              # Format execution details
              ${{ inputs.execution_details_script }} "$EXEC_FILE" /tmp/execution_details.md

              if [ ! -f /tmp/execution_details.md ]; then
                echo "‚ö†Ô∏è Failed to generate execution details"
                exit 0
              fi

              # Find comment to update (priority: ack > final > latest)
              COMMENT_ID="${{ inputs.acknowledgment_comment_id }}"

              if [ -z "$COMMENT_ID" ] && [ -f /tmp/claude_final_comment_id.txt ]; then
                COMMENT_ID=$(cat /tmp/claude_final_comment_id.txt)
                echo "üìã Using final comment ID: $COMMENT_ID"
              fi

              if [ -z "$COMMENT_ID" ]; then
                # Find latest Claude/bot comment
                ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"
                if [ -n "$ISSUE_NUM" ]; then
                  COMMENT_ID=$(gh api "/repos/${{ github.repository }}/issues/$ISSUE_NUM/comments" \
                    --jq '.[-1] | select(.user.login == "claude[bot]" or (.user.login | test("Bot$"))) | .id' 2>/dev/null || echo "")
                  echo "üìã Found latest bot comment ID: $COMMENT_ID"
                fi
              fi

              if [ -z "$COMMENT_ID" ]; then
                echo "‚ö†Ô∏è Could not find comment to update"
                exit 0
              fi

              # Determine API endpoint
              if [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
                API_ENDPOINT="/repos/${{ github.repository }}/pulls/comments/$COMMENT_ID"
              else
                API_ENDPOINT="/repos/${{ github.repository }}/issues/comments/$COMMENT_ID"
              fi

              echo "üìù Updating comment via: $API_ENDPOINT"

              # Get current body and check if details already present
              CURRENT_BODY=$(gh api "$API_ENDPOINT" --jq '.body' 2>/dev/null || echo "")

              if [ -z "$CURRENT_BODY" ]; then
                echo "‚ö†Ô∏è Could not fetch comment body"
                exit 0
              fi

              if echo "$CURRENT_BODY" | grep -q "üí≠ How I worked on this"; then
                echo "‚úÖ Execution details already present"
                exit 0
              fi

              # Append execution details
              printf '%s\n\n%s' "$CURRENT_BODY" "$(cat /tmp/execution_details.md)" | \
                gh api -X PATCH "$API_ENDPOINT" -F body=@- 2>/dev/null

              if [ $? -eq 0 ]; then
                echo "‚úÖ Appended execution details to comment #$COMMENT_ID"
              else
                echo "‚ö†Ô∏è Failed to update comment"
              fi
