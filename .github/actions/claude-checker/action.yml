name: "Claude Checker"
description: "Generic Claude-based checker with orchestration features"
author: "MoosicBox"

inputs:
    # === Command ===
    command:
        description: "Command to run: create-branch, create-pr, check"
        required: false
        default: "check"

    # === Authentication (Required) ===
    github_token:
        description: "GitHub token with write permissions"
        required: true
    claude_token:
        description: "Claude Code OAuth token"
        required: false # Not required for create-branch and create-pr commands

    # === Prompt Template (One Required) ===
    prompt_template:
        description: "Built-in template: readme, rustdoc, examples, issue, pr, code-review"
        required: false
    prompt_template_file:
        description: "Path to custom template file"
        required: false
    prompt_template_text:
        description: "Inline template text"
        required: false

    # === Template Variables ===
    template_vars:
        description: "YAML/JSON object of template variables"
        required: false
        default: "{}"

    # === Behavior ===
    branch_name:
        description: "Branch name (overrides template default, or used for create-branch/create-pr)"
        required: false
    branch_prefix:
        description: "Branch prefix for auto-generation (create-branch command)"
        required: false
        default: "claude-updates"
    existing_branch:
        description: "Use existing branch if it exists (create-branch command)"
        required: false
        default: "true"
    git_user_name:
        description: "Git user name for commits"
        required: false
        default: "github-actions[bot]"
    git_user_email:
        description: "Git user email"
        required: false
        default: "github-actions[bot]@users.noreply.github.com"
    commit_message:
        description: "Commit message (supports variables)"
        required: false
    auto_commit:
        description: "Automatically commit changes"
        required: false
        default: "true"

    # === Stream Watcher (Optional) ===
    enable_stream_watcher:
        description: "Enable live progress updates"
        required: false
        default: "false"
    stream_comment_id:
        description: "Comment ID for live updates"
        required: false
    stream_comment_type:
        description: "Comment type: issue, pr_issue_comment, pr_review_comment"
        required: false

    # === Execution Details (Optional) ===
    enable_execution_details:
        description: "Append execution details to comment"
        required: false
        default: "false"
    execution_details_script:
        description: "Path to execution details script"
        required: false
        default: ".github/scripts/format-execution-details.sh"
    acknowledgment_comment_id:
        description: "Comment ID to append details to"
        required: false

    # === Execution Details Artifacts (Optional) ===
    enable_execution_details_artifact:
        description: "Upload execution details as artifact"
        required: false
        default: "false"
    artifact_name_prefix:
        description: "Prefix for artifact name (e.g., 'rustdoc', 'readme')"
        required: false
        default: ""
    artifact_package_name:
        description: "Package name for artifact naming (e.g., 'clippier')"
        required: false
        default: ""
    artifact_retention_days:
        description: "Artifact retention days"
        required: false
        default: "30"

    # === Co-Author Attribution (Optional) ===
    enable_coauthor_attribution:
        description: "Add co-author to commits"
        required: false
        default: "false"
    coauthor_login:
        description: "Co-author GitHub username (auto-detected)"
        required: false
    coauthor_id:
        description: "Co-author GitHub ID (auto-detected)"
        required: false
    coauthor_email:
        description: "Co-author email (auto-detected)"
        required: false
    trigger_comment_url:
        description: "Trigger URL (auto-detected)"
        required: false

    # === Resilient Push (Optional) ===
    enable_resilient_push:
        description: "Enable push with retry/rebase"
        required: false
        default: "true"
    push_max_retries:
        description: "Max push retry attempts"
        required: false
        default: "5"
    push_timeout_seconds:
        description: "Push timeout in seconds"
        required: false
        default: "30"
    fallback_branch_prefix:
        description: "Prefix for fallback branch"
        required: false
        default: "claude-fallback"

    # === Commit Message Extraction ===
    extract_commit_message:
        description: "Extract commit description from output"
        required: false
        default: "true"
    commit_message_start_marker:
        description: "Start marker for extraction"
        required: false
        default: "COMMIT_MESSAGE_START"
    commit_message_end_marker:
        description: "End marker for extraction"
        required: false
        default: "COMMIT_MESSAGE_END"

    # === PR Creation (create-pr command) ===
    pr_base_branch:
        description: "Base branch for PR (create-pr command)"
        required: false
        default: "master"
    pr_title:
        description: "PR title (supports template variables, create-pr command)"
        required: false
        default: "üìù Automated updates from Claude"
    pr_body:
        description: "PR body (supports template variables, create-pr command)"
        required: false
        default: ""
    pr_labels:
        description: "Comma-separated PR labels (create-pr command)"
        required: false
        default: "automated"
    pr_skip_if_no_changes:
        description: "Skip PR creation if no changes (create-pr command)"
        required: false
        default: "true"

    # === Claude Config ===
    model:
        description: "Claude model"
        required: false
    max_tokens:
        description: "Max tokens"
        required: false
    max_turns:
        description: "Max turns"
        required: false
    claude_args:
        description: "Additional Claude args"
        required: false

    # === Advanced ===
    working_directory:
        description: "Working directory"
        required: false
        default: "."

outputs:
    has_changes:
        description: "true if changes were made"
        value: ${{ steps.detect_changes.outputs.has_changes }}
    files_changed:
        description: "Space-separated changed files"
        value: ${{ steps.detect_changes.outputs.files_changed }}
    branch_name:
        description: "Branch used"
        value: ${{ steps.create_branch.outputs.branch_name || steps.setup_branch.outputs.branch_name }}
    execution_file:
        description: "Execution details file path (JSON)"
        value: ${{ steps.claude.outputs.execution_file }}
    execution_details_file:
        description: "Formatted execution details markdown file path"
        value: ${{ steps.format_execution_details.outputs.details_file }}
    artifact_uploaded:
        description: "true if execution details artifact was uploaded"
        value: ${{ steps.upload_execution_details.outputs.uploaded }}
    resolved_template_vars:
        description: "Resolved variables JSON"
        value: ${{ steps.resolve_template.outputs.resolved_vars }}

    # Push outputs
    push_status:
        description: "Push status: success, no_changes, fallback, failed"
        value: ${{ steps.push_changes.outputs.push_status }}
    push_branch:
        description: "Branch pushed to"
        value: ${{ steps.push_changes.outputs.push_branch }}
    fallback_branch:
        description: "Fallback branch (if created)"
        value: ${{ steps.push_changes.outputs.fallback_branch }}
    compare_url:
        description: "Compare URL for fallback"
        value: ${{ steps.push_changes.outputs.compare_url }}

    commit_created:
        description: "true if commit was created"
        value: ${{ steps.commit_changes.outputs.commit_created }}

    # create-branch command outputs
    branch_exists:
        description: "true if branch already existed (create-branch)"
        value: ${{ steps.create_branch.outputs.branch_exists }}
    branch_action:
        description: "created or checked_out (create-branch)"
        value: ${{ steps.create_branch.outputs.branch_action }}

    # create-pr command outputs
    pr_created:
        description: "true if PR was created or updated (create-pr)"
        value: ${{ steps.create_pr.outputs.pr_created }}
    pr_number:
        description: "PR number (create-pr)"
        value: ${{ steps.create_pr.outputs.pr_number }}
    pr_url:
        description: "PR URL (create-pr)"
        value: ${{ steps.create_pr.outputs.pr_url }}
    pr_action:
        description: "created, updated, or skipped (create-pr)"
        value: ${{ steps.create_pr.outputs.pr_action }}

runs:
    using: "composite"
    steps:
        - name: Validate command
          shell: bash
          run: |
              COMMAND="${{ inputs.command }}"
              case "$COMMAND" in
                create-branch|create-pr|check)
                  echo "‚úÖ Valid command: $COMMAND"
                  ;;
                *)
                  echo "‚ùå Error: Invalid command '$COMMAND'. Must be: create-branch, create-pr, or check"
                  exit 1
                  ;;
              esac

        - name: Validate inputs
          if: inputs.command == 'check'
          shell: bash
          run: |
              if [ -z "${{ inputs.prompt_template }}" ] && \
                 [ -z "${{ inputs.prompt_template_file }}" ] && \
                 [ -z "${{ inputs.prompt_template_text }}" ]; then
                echo "‚ùå Error: One of prompt_template, prompt_template_file, or prompt_template_text must be provided for 'check' command"
                exit 1
              fi

              if [ -z "${{ inputs.claude_token }}" ]; then
                echo "‚ùå Error: claude_token is required for 'check' command"
                exit 1
              fi

              echo "‚úÖ Input validation passed"

        - name: Validate create-pr inputs
          if: inputs.command == 'create-pr'
          shell: bash
          run: |
              if [ -z "${{ inputs.branch_name }}" ]; then
                echo "‚ùå Error: branch_name is required for 'create-pr' command"
                exit 1
              fi
              echo "‚úÖ create-pr validation passed"

        # ========================================
        # CREATE-BRANCH COMMAND
        # ========================================

        - name: Configure Git (create-branch)
          if: inputs.command == 'create-branch'
          shell: bash
          run: |
              git config user.name "${{ inputs.git_user_name }}"
              git config user.email "${{ inputs.git_user_email }}"

        - name: Create or checkout branch
          if: inputs.command == 'create-branch'
          id: create_branch
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              # Determine branch name
              if [ -n "${{ inputs.branch_name }}" ]; then
                BRANCH_NAME="${{ inputs.branch_name }}"
                echo "Using provided branch name: $BRANCH_NAME"
              else
                BRANCH_DATE=$(date +%Y%m%d%H%M%S)
                BRANCH_NAME="${{ inputs.branch_prefix }}-${BRANCH_DATE}-${{ github.run_id }}"
                echo "Generated branch name: $BRANCH_NAME"
              fi

              echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

              # Check if branch exists
              if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
                echo "branch_exists=true" >> $GITHUB_OUTPUT
                echo "branch_action=checked_out" >> $GITHUB_OUTPUT

                if [ "${{ inputs.existing_branch }}" == "true" ]; then
                  echo "üìç Branch $BRANCH_NAME already exists, checking out"
                  git fetch origin "$BRANCH_NAME"
                  git checkout "$BRANCH_NAME"
                else
                  echo "‚ùå Error: Branch $BRANCH_NAME already exists and existing_branch=false"
                  exit 1
                fi
              else
                echo "branch_exists=false" >> $GITHUB_OUTPUT
                echo "branch_action=created" >> $GITHUB_OUTPUT
                echo "üå± Creating new branch: $BRANCH_NAME"
                git checkout -b "$BRANCH_NAME"
                git push origin "$BRANCH_NAME"
              fi

              echo "‚úÖ Branch ready: $BRANCH_NAME"

        # ========================================
        # CHECK COMMAND (existing functionality)
        # ========================================

        - name: Setup Node.js for template processing
          if: inputs.command == 'check'
          uses: actions/setup-node@v4
          with:
              node-version: "20"

        - name: Install dependencies
          if: inputs.command == 'check'
          shell: bash
          working-directory: ${{ github.action_path }}
          run: |
              if [ ! -d "node_modules" ]; then
                npm install
              fi

        - name: Resolve template and variables
          if: inputs.command == 'check'
          id: resolve_template
          shell: bash
          working-directory: ${{ github.action_path }}
          env:
              PROMPT_TEMPLATE: ${{ inputs.prompt_template }}
              PROMPT_TEMPLATE_FILE: ${{ inputs.prompt_template_file }}
              PROMPT_TEMPLATE_TEXT: ${{ inputs.prompt_template_text }}
              TEMPLATE_VARS: ${{ inputs.template_vars }}
              GITHUB_CONTEXT: ${{ toJSON(github) }}
          run: |
              node src/resolve-template.js

        - name: Output resolved prompt for debugging
          if: inputs.command == 'check'
          shell: bash
          run: |
              echo "üìã ========================================="
              echo "üìä Resolved Variables:"
              printf '%s\n' '${{ steps.resolve_template.outputs.resolved_vars }}'
              echo ""
              echo "üìã ========================================="
              echo "üìã RESOLVED PROMPT (with all variables interpolated):"
              echo "üìã ========================================="
              printf '%s\n' '${{ steps.resolve_template.outputs.rendered_prompt }}'
              echo "üìã ========================================="

        - name: Setup branch (check command)
          if: inputs.command == 'check'
          id: setup_branch
          shell: bash
          env:
              RESOLVED_BRANCH_NAME: ${{ steps.resolve_template.outputs.branch_name }}
              INPUT_BRANCH_NAME: ${{ inputs.branch_name }}
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              # Use explicit input branch, or resolved from template, or generate default
              if [ -n "$INPUT_BRANCH_NAME" ]; then
                BRANCH_NAME="$INPUT_BRANCH_NAME"
              elif [ -n "$RESOLVED_BRANCH_NAME" ]; then
                BRANCH_NAME="$RESOLVED_BRANCH_NAME"
              else
                BRANCH_NAME="claude-updates-${{ github.run_id }}"
              fi

              echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

              # Check if branch exists
              if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
                echo "üìç Branch $BRANCH_NAME already exists, checking out"
                git fetch origin "$BRANCH_NAME"
                git checkout "$BRANCH_NAME"
              else
                echo "üå± Creating new branch: $BRANCH_NAME"
                git checkout -b "$BRANCH_NAME"
              fi

        - name: Setup git configuration (check command)
          if: inputs.command == 'check'
          shell: bash
          run: |
              git config user.name "MoosicBoxBot"
              git config user.email "MoosicBoxBot@gmail.com"

        - name: Check stream watcher prerequisites
          if: inputs.command == 'check' && inputs.enable_stream_watcher == 'true'
          shell: bash
          run: |
              # Verify inotify-tools is installed
              if ! command -v inotifywait &> /dev/null; then
                echo "‚ö†Ô∏è WARNING: inotify-tools not installed. Stream watcher will be disabled."
                echo "Install with: sudo apt-get install -y inotify-tools"
                echo "stream_watcher_enabled=false" >> $GITHUB_ENV
              else
                echo "‚úÖ inotify-tools found"
                echo "stream_watcher_enabled=true" >> $GITHUB_ENV
              fi

              # Stream watcher script is bundled with action
              STREAM_WATCHER_SCRIPT="${{ github.action_path }}/scripts/stream-watcher.sh"
              if [ ! -f "$STREAM_WATCHER_SCRIPT" ]; then
                echo "‚ö†Ô∏è ERROR: Stream watcher script missing from action"
                echo "stream_watcher_enabled=false" >> $GITHUB_ENV
              else
                echo "stream_watcher_script=$STREAM_WATCHER_SCRIPT" >> $GITHUB_ENV
              fi

              # Verify comment ID provided
              if [ -z "${{ inputs.stream_comment_id }}" ]; then
                echo "‚ö†Ô∏è WARNING: stream_comment_id not provided"
                echo "stream_watcher_enabled=false" >> $GITHUB_ENV
              fi

        - name: Start stream watcher
          if: inputs.command == 'check' && inputs.enable_stream_watcher == 'true' && env.stream_watcher_enabled == 'true'
          shell: bash
          run: |
              STREAM_FILE="${{ runner.temp }}/claude-stream.jsonl"

              ${{ env.stream_watcher_script }} \
                "$STREAM_FILE" \
                "${{ github.repository }}" \
                "${{ inputs.github_token }}" \
                "${{ inputs.stream_comment_id }}" \
                "${{ inputs.stream_comment_type }}" \
                > /tmp/stream-watcher.log 2>&1 &

              WATCHER_PID=$!
              echo $WATCHER_PID > /tmp/stream_watcher_pid.txt
              echo "üîÑ Stream watcher started (PID: $WATCHER_PID)"
              echo "üìã Stream file: $STREAM_FILE"

        - name: Run Claude Code
          if: inputs.command == 'check'
          id: claude
          uses: BSteffaniak/claude-code-action@dev
          with:
              claude_code_oauth_token: ${{ inputs.claude_token }}
              stream_output_file: ${{ inputs.enable_stream_watcher == 'true' && env.stream_watcher_enabled == 'true' && format('{0}/claude-stream.jsonl', runner.temp) || '' }}
              prompt: ${{ steps.resolve_template.outputs.rendered_prompt }}
              claude_args: ${{ inputs.claude_args }}

        - name: Stop stream watcher
          if: always() && inputs.command == 'check' && inputs.enable_stream_watcher == 'true' && env.stream_watcher_enabled == 'true'
          shell: bash
          run: |
              if [ -f /tmp/stream_watcher_pid.txt ]; then
                WATCHER_PID=$(cat /tmp/stream_watcher_pid.txt)

                echo "‚è≥ Waiting for stream watcher (PID: $WATCHER_PID) to complete..."

                # Graceful shutdown (30 seconds)
                for i in {1..30}; do
                  if ! kill -0 $WATCHER_PID 2>/dev/null; then
                    echo "‚úÖ Stream watcher completed"
                    break
                  fi
                  sleep 1
                done

                # Force shutdown if still running
                if kill -0 $WATCHER_PID 2>/dev/null; then
                  echo "‚ö†Ô∏è Stream watcher still running, sending SIGTERM..."
                  kill -TERM $WATCHER_PID 2>/dev/null || true
                  sleep 2

                  if kill -0 $WATCHER_PID 2>/dev/null; then
                    echo "‚ö†Ô∏è Forcing stream watcher to stop..."
                    kill -9 $WATCHER_PID 2>/dev/null || true
                  fi
                fi

                # Show logs if available
                if [ -f /tmp/stream-watcher.log ]; then
                  echo ""
                  echo "üìã Stream watcher logs:"
                  cat /tmp/stream-watcher.log
                fi
              fi

        - name: Detect changes
          if: inputs.command == 'check'
          id: detect_changes
          shell: bash
          run: |
              if [ -n "$(git status --porcelain)" ] || [ "$(git rev-list --count origin/${{ steps.setup_branch.outputs.branch_name }}..HEAD 2>/dev/null || echo 0)" != "0" ]; then
                echo "has_changes=true" >> $GITHUB_OUTPUT
                echo "files_changed=$(git diff --name-only HEAD 2>/dev/null | tr '\n' ' ')" >> $GITHUB_OUTPUT
                echo "‚úÖ Changes detected"
              else
                echo "has_changes=false" >> $GITHUB_OUTPUT
                echo "files_changed=" >> $GITHUB_OUTPUT
                echo "üì≠ No changes detected"
              fi

        - name: Commit changes
          id: commit_changes
          if: inputs.command == 'check' && inputs.auto_commit == 'true' && steps.detect_changes.outputs.has_changes == 'true'
          shell: bash
          run: |
              # Get base commit message from template or input
              BASE_COMMIT_MSG="${{ inputs.commit_message }}"
              if [ -z "$BASE_COMMIT_MSG" ]; then
                BASE_COMMIT_MSG="${{ steps.resolve_template.outputs.commit_message }}"
              fi
              if [ -z "$BASE_COMMIT_MSG" ]; then
                BASE_COMMIT_MSG="chore: update via Claude checker"
              fi

              # Extract detailed description from Claude output if enabled
              COMMIT_DESC=""
              if [ "${{ inputs.extract_commit_message }}" = "true" ] && [ -f output.txt ]; then
                echo "üìã Extracting commit description from Claude output..."

                # Try JSONL format first (from claude-code-action)
                COMMIT_DESC=$(grep "${{ inputs.commit_message_start_marker }}" output.txt 2>/dev/null | head -1 | \
                  jq -r '.message.content[0].text |
                  split("${{ inputs.commit_message_start_marker }}\n")[1] |
                  split("\n${{ inputs.commit_message_end_marker }}")[0]' 2>/dev/null || echo "")

                # Try plain text format
                if [ -z "$COMMIT_DESC" ]; then
                  COMMIT_DESC=$(sed -n '/${{ inputs.commit_message_start_marker }}/,/${{ inputs.commit_message_end_marker }}/p' output.txt 2>/dev/null | \
                    sed '1d;$d' || echo "")
                fi
              fi

              # Remove output.txt if it exists (from claude-code-action)
              rm -f output.txt

              # Check for uncommitted changes
              if [ -z "$(git status --porcelain)" ]; then
                echo "üì≠ No uncommitted changes"
                echo "commit_created=false" >> $GITHUB_OUTPUT
                exit 0
              fi

              echo "üìù Changes detected, preparing commit..."

              git add -A

              # Create commit using heredoc to prevent command injection
              if [ -n "$COMMIT_DESC" ] && [ "$COMMIT_DESC" != "null" ]; then
                echo "üìã Using detailed commit description:"
                echo "$COMMIT_DESC"
                git commit -F - <<'EOF'
              $BASE_COMMIT_MSG

              $COMMIT_DESC
              EOF
              else
                echo "üìã Using base commit message: $BASE_COMMIT_MSG"
                git commit -F - <<'EOF'
              $BASE_COMMIT_MSG
              EOF
              fi

              echo "commit_created=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Commit created"

        - name: Add co-author attribution to commits
          if: always() && inputs.command == 'check' && inputs.enable_coauthor_attribution == 'true' && steps.commit_changes.outputs.commit_created == 'true'
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              # Count commits to process
              DEFAULT_BRANCH="${{ github.event.repository.default_branch || 'master' }}"
              COMMITS_AHEAD=$(git rev-list --count origin/$DEFAULT_BRANCH..HEAD 2>/dev/null || echo "0")

              if [ "$COMMITS_AHEAD" = "0" ]; then
                echo "üì≠ No commits to add co-author to"
                exit 0
              fi

              echo "üìä Found $COMMITS_AHEAD commit(s) to process"

              # Determine co-author from inputs or event context
              COAUTHOR_LOGIN="${{ inputs.coauthor_login }}"
              COAUTHOR_ID="${{ inputs.coauthor_id }}"
              COAUTHOR_EMAIL="${{ inputs.coauthor_email }}"

              if [ -z "$COAUTHOR_LOGIN" ]; then
                COAUTHOR_LOGIN="${{ github.event.comment.user.login || github.event.review.user.login || github.event.issue.user.login || github.actor }}"
                COAUTHOR_ID="${{ github.event.comment.user.id || github.event.review.user.id || github.event.issue.user.id }}"
              fi

              if [ -z "$COAUTHOR_LOGIN" ]; then
                echo "‚ö†Ô∏è Could not determine co-author, skipping"
                exit 0
              fi

              # Try to find real email if not provided
              if [ -z "$COAUTHOR_EMAIL" ]; then
                echo "üîç Searching for email for $COAUTHOR_LOGIN..."

                # Try user profile API
                COAUTHOR_EMAIL=$(gh api "/users/$COAUTHOR_LOGIN" --jq '.email // empty' 2>/dev/null || echo "")

                # Try recent commits
                if [ -z "$COAUTHOR_EMAIL" ]; then
                  COAUTHOR_EMAIL=$(gh api "/users/$COAUTHOR_LOGIN/events/public" --jq '
                    [.[] | select(.type == "PushEvent") | .payload.commits[]? | .author.email]
                    | map(select(. != null and . != ""))
                    | first // empty
                  ' 2>/dev/null || echo "")
                fi

                # Fallback to noreply
                if [ -z "$COAUTHOR_EMAIL" ] || [ "$COAUTHOR_EMAIL" = "null" ]; then
                  COAUTHOR_EMAIL="${COAUTHOR_ID}+${COAUTHOR_LOGIN}@users.noreply.github.com"
                fi
              fi

              COAUTHOR_LINE="Co-authored-by: ${COAUTHOR_LOGIN} <${COAUTHOR_EMAIL}>"
              echo "üë• Co-author: $COAUTHOR_LINE"

              # Determine trigger URL
              COMMENT_URL="${{ inputs.trigger_comment_url }}"
              if [ -z "$COMMENT_URL" ]; then
                COMMENT_URL="${{ github.event.comment.html_url || github.event.review.html_url || github.event.issue.html_url }}"
              fi

              if [ -n "$COMMENT_URL" ]; then
                echo "üîó Trigger URL: $COMMENT_URL"
              fi

              # Create rebase script to amend all commits
              cat > /tmp/add_coauthor.sh << 'SCRIPT'
              #!/bin/bash
              MSG=$(git log -1 --pretty=%B)
              MODIFIED=false

              # Add trigger URL if not present
              if [ -n "$COMMENT_URL" ] && ! echo "$MSG" | grep -qF "Triggered-by:"; then
                if echo "$MSG" | tail -1 | grep -q '^$'; then
                  MSG=$(printf '%sTriggered-by: %s\n' "$MSG" "$COMMENT_URL")
                else
                  MSG=$(printf '%s\n\nTriggered-by: %s\n' "$MSG" "$COMMENT_URL")
                fi
                MODIFIED=true
              fi

              # Add co-author if not present
              if ! echo "$MSG" | grep -qF "$COAUTHOR_LINE"; then
                if echo "$MSG" | tail -1 | grep -q '^$'; then
                  MSG=$(printf '%s%s\n' "$MSG" "$COAUTHOR_LINE")
                else
                  MSG=$(printf '%s\n\n%s\n' "$MSG" "$COAUTHOR_LINE")
                fi
                MODIFIED=true
              fi

              # Amend if modified
              if [ "$MODIFIED" = "true" ]; then
                printf '%s' "$MSG" | git commit --amend -F -
              fi
              SCRIPT

              chmod +x /tmp/add_coauthor.sh
              export COAUTHOR_LINE
              export COMMENT_URL

              # Rebase and amend all commits
              BASE_COMMIT=$(git merge-base HEAD origin/$DEFAULT_BRANCH 2>/dev/null || echo "origin/$DEFAULT_BRANCH")

              if GIT_SEQUENCE_EDITOR=true git rebase -i --exec "/tmp/add_coauthor.sh" $BASE_COMMIT 2>&1; then
                echo "‚úÖ Added co-author to $COMMITS_AHEAD commit(s)"
              else
                echo "‚ö†Ô∏è Failed to add co-author, continuing anyway..."
                git rebase --abort 2>/dev/null || true
              fi

        - name: Push changes with resilient retry
          id: push_changes
          if: always() && inputs.command == 'check' && inputs.enable_resilient_push == 'true'
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              git remote set-url origin "https://x-access-token:${{ inputs.github_token }}@github.com/${{ github.repository }}.git"

              TARGET_BRANCH="${{ steps.setup_branch.outputs.branch_name }}"
              DEFAULT_BRANCH="${{ github.event.repository.default_branch || 'master' }}"

              # Check if there are commits to push
              COMMITS_AHEAD=$(git rev-list --count origin/$TARGET_BRANCH..HEAD 2>/dev/null || echo "0")

              if [ "$COMMITS_AHEAD" = "0" ]; then
                echo "üì≠ No commits to push"
                echo "push_status=no_changes" >> $GITHUB_OUTPUT
                exit 0
              fi

              echo "üìä Found $COMMITS_AHEAD commit(s) to push to $TARGET_BRANCH"

              # Resilient push with retry logic
              MAX_RETRIES=${{ inputs.push_max_retries }}
              RETRY_COUNT=0
              BACKOFF=1
              MAX_TIME=${{ inputs.push_timeout_seconds }}
              START_TIME=$(date +%s)

              while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                ELAPSED=$(($(date +%s) - START_TIME))
                if [ $ELAPSED -gt $MAX_TIME ]; then
                  echo "‚è±Ô∏è Timeout reached after ${ELAPSED}s"
                  break
                fi

                echo "üì§ Push attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."

                if git push origin "$TARGET_BRANCH" 2>&1; then
                  echo "‚úÖ Successfully pushed to $TARGET_BRANCH"
                  echo "push_status=success" >> $GITHUB_OUTPUT
                  echo "push_branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT
                  exit 0
                fi

                echo "‚ö†Ô∏è Push rejected, attempting rebase..."

                # Fetch latest changes
                git fetch origin "$TARGET_BRANCH"

                # Attempt rebase
                if git rebase "origin/$TARGET_BRANCH" 2>&1; then
                  echo "‚úÖ Rebase successful, retrying push..."
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                  sleep $BACKOFF
                  BACKOFF=$((BACKOFF * 2))
                  continue
                else
                  # Check for conflicts
                  if git status | grep -E "both modified|both added|both deleted|conflict" >/dev/null 2>&1; then
                    echo "üö´ CONFLICTS DETECTED during rebase"
                    git rebase --abort 2>/dev/null || true
                    break
                  else
                    echo "‚ö†Ô∏è Rebase failed for non-conflict reason"
                    git rebase --abort 2>/dev/null || true
                    break
                  fi
                fi
              done

              # Create fallback branch if push failed
              echo "üîÄ Creating fallback branch..."
              TIMESTAMP=$(date +%s)
              FALLBACK_BRANCH="${{ inputs.fallback_branch_prefix }}-${{ github.run_id }}-${TIMESTAMP}"

              # Ensure clean state
              git rebase --abort 2>/dev/null || true

              # Create fallback branch from current commits
              git checkout -B "$FALLBACK_BRANCH"

              echo "üì§ Pushing to fallback branch: $FALLBACK_BRANCH"
              if git push origin "$FALLBACK_BRANCH" 2>&1; then
                echo "‚úÖ Successfully pushed to fallback branch"
                echo "push_status=fallback" >> $GITHUB_OUTPUT
                echo "push_branch=$FALLBACK_BRANCH" >> $GITHUB_OUTPUT
                echo "fallback_branch=$FALLBACK_BRANCH" >> $GITHUB_OUTPUT
                echo "original_branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT
                echo "commits_count=$COMMITS_AHEAD" >> $GITHUB_OUTPUT

                # Create compare URL
                COMPARE_URL="${{ github.server_url }}/${{ github.repository }}/compare/${TARGET_BRANCH}...${FALLBACK_BRANCH}"
                echo "compare_url=$COMPARE_URL" >> $GITHUB_OUTPUT

                echo ""
                echo "‚ö†Ô∏è FALLBACK BRANCH CREATED"
                echo "Compare: $COMPARE_URL"

                exit 0
              else
                echo "‚ùå Failed to push even to fallback branch"
                echo "push_status=failed" >> $GITHUB_OUTPUT
                exit 1
              fi

        - name: Format and append execution details
          if: always() && inputs.command == 'check' && inputs.enable_execution_details == 'true' && steps.claude.outputs.execution_file != ''
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              EXEC_FILE="${{ steps.claude.outputs.execution_file }}"

              if [ ! -f "$EXEC_FILE" ] || [ ! -s "$EXEC_FILE" ]; then
                echo "‚ö†Ô∏è Execution file not found or empty"
                exit 0
              fi

              echo "üìä Execution file found: $EXEC_FILE"

              # Check if formatting script exists
              if [ ! -f "${{ inputs.execution_details_script }}" ]; then
                echo "‚ö†Ô∏è Execution details script not found: ${{ inputs.execution_details_script }}"
                exit 0
              fi

              # Format execution details
              ${{ inputs.execution_details_script }} "$EXEC_FILE" /tmp/execution_details.md

              if [ ! -f /tmp/execution_details.md ]; then
                echo "‚ö†Ô∏è Failed to generate execution details"
                exit 0
              fi

              # Find comment to update (priority: ack > final > latest)
              COMMENT_ID="${{ inputs.acknowledgment_comment_id }}"

              if [ -z "$COMMENT_ID" ] && [ -f /tmp/claude_final_comment_id.txt ]; then
                COMMENT_ID=$(cat /tmp/claude_final_comment_id.txt)
                echo "üìã Using final comment ID: $COMMENT_ID"
              fi

              if [ -z "$COMMENT_ID" ]; then
                # Find latest Claude/bot comment
                ISSUE_NUM="${{ github.event.issue.number || github.event.pull_request.number }}"
                if [ -n "$ISSUE_NUM" ]; then
                  COMMENT_ID=$(gh api "/repos/${{ github.repository }}/issues/$ISSUE_NUM/comments" \
                    --jq '.[-1] | select(.user.login == "claude[bot]" or (.user.login | test("Bot$"))) | .id' 2>/dev/null || echo "")
                  echo "üìã Found latest bot comment ID: $COMMENT_ID"
                fi
              fi

              if [ -z "$COMMENT_ID" ]; then
                echo "‚ö†Ô∏è Could not find comment to update"
                exit 0
              fi

              # Determine API endpoint
              if [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
                API_ENDPOINT="/repos/${{ github.repository }}/pulls/comments/$COMMENT_ID"
              else
                API_ENDPOINT="/repos/${{ github.repository }}/issues/comments/$COMMENT_ID"
              fi

              echo "üìù Updating comment via: $API_ENDPOINT"

              # Get current body and check if details already present
              CURRENT_BODY=$(gh api "$API_ENDPOINT" --jq '.body' 2>/dev/null || echo "")

              if [ -z "$CURRENT_BODY" ]; then
                echo "‚ö†Ô∏è Could not fetch comment body"
                exit 0
              fi

              if echo "$CURRENT_BODY" | grep -q "üí≠ How I worked on this"; then
                echo "‚úÖ Execution details already present"
                exit 0
              fi

              # Append execution details
              printf '%s\n\n%s' "$CURRENT_BODY" "$(cat /tmp/execution_details.md)" | \
                gh api -X PATCH "$API_ENDPOINT" -F body=@- 2>/dev/null

              if [ $? -eq 0 ]; then
                echo "‚úÖ Appended execution details to comment #$COMMENT_ID"
              else
                echo "‚ö†Ô∏è Failed to update comment"
              fi

        - name: Format execution details for artifact
          if: always() && inputs.command == 'check' && inputs.enable_execution_details_artifact == 'true' && steps.claude.outputs.execution_file != ''
          id: format_execution_details
          shell: bash
          run: |
              EXEC_FILE="${{ steps.claude.outputs.execution_file }}"
              PACKAGE_NAME="${{ inputs.artifact_package_name }}"

              # Generate output file path
              if [ -n "$PACKAGE_NAME" ]; then
                  OUTPUT_FILE="/tmp/execution-details-${PACKAGE_NAME}.md"
              else
                  OUTPUT_FILE="/tmp/execution-details.md"
              fi

              if [ -f "$EXEC_FILE" ] && [ -s "$EXEC_FILE" ]; then
                  echo "üìä Formatting execution details for artifact..."

                  # Check if formatting script exists
                  if [ ! -f "${{ inputs.execution_details_script }}" ]; then
                      echo "‚ö†Ô∏è Execution details script not found: ${{ inputs.execution_details_script }}"
                      exit 0
                  fi

                  # Format execution details
                  ${{ inputs.execution_details_script }} "$EXEC_FILE" "$OUTPUT_FILE"

                  if [ -f "$OUTPUT_FILE" ]; then
                      echo "‚úÖ Created execution details artifact: $OUTPUT_FILE"
                      echo "details_file=$OUTPUT_FILE" >> $GITHUB_OUTPUT
                  else
                      echo "‚ö†Ô∏è Failed to generate execution details"
                  fi
              else
                  echo "‚ÑπÔ∏è No execution file available"
              fi

        - name: Upload execution details artifact
          if: always() && inputs.command == 'check' && inputs.enable_execution_details_artifact == 'true' && steps.format_execution_details.outputs.details_file != ''
          uses: actions/upload-artifact@v4
          with:
              name: ${{ inputs.artifact_name_prefix != '' && format('execution-details-{0}-{1}', inputs.artifact_name_prefix, inputs.artifact_package_name) || format('execution-details-{0}', inputs.artifact_package_name || 'default') }}
              path: ${{ steps.format_execution_details.outputs.details_file }}
              retention-days: ${{ inputs.artifact_retention_days }}
              if-no-files-found: warn

        - name: Set artifact uploaded flag
          if: always() && inputs.command == 'check' && inputs.enable_execution_details_artifact == 'true'
          id: upload_execution_details
          shell: bash
          run: |
              if [ -f "${{ steps.format_execution_details.outputs.details_file }}" ]; then
                  echo "uploaded=true" >> $GITHUB_OUTPUT
              else
                  echo "uploaded=false" >> $GITHUB_OUTPUT
              fi

        # ========================================
        # CREATE-PR COMMAND
        # ========================================

        - name: Check for changes (create-pr)
          if: inputs.command == 'create-pr'
          id: check_pr_changes
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              # Fetch both branches to compare
              git fetch origin ${{ inputs.pr_base_branch }} || true
              git fetch origin ${{ inputs.branch_name }} || true

              # Check for changes between base and head
              if git diff origin/${{ inputs.pr_base_branch }}...origin/${{ inputs.branch_name }} --quiet; then
                echo "has_changes=false" >> $GITHUB_OUTPUT
                echo "‚ÑπÔ∏è  No changes detected between ${{ inputs.pr_base_branch }} and ${{ inputs.branch_name }}"
              else
                echo "has_changes=true" >> $GITHUB_OUTPUT
                CHANGED_FILES=$(git diff origin/${{ inputs.pr_base_branch }}...origin/${{ inputs.branch_name }} --name-only | wc -l)
                echo "‚úÖ Found changes: $CHANGED_FILES files modified"
              fi

        - name: Skip PR creation (no changes)
          if: inputs.command == 'create-pr' && inputs.pr_skip_if_no_changes == 'true' && steps.check_pr_changes.outputs.has_changes == 'false'
          id: skip_pr
          shell: bash
          run: |
              echo "pr_created=false" >> $GITHUB_OUTPUT
              echo "pr_action=skipped" >> $GITHUB_OUTPUT
              echo "‚è≠Ô∏è  Skipping PR creation - no changes detected"

        - name: Check if PR exists
          if: inputs.command == 'create-pr' && (inputs.pr_skip_if_no_changes == 'false' || steps.check_pr_changes.outputs.has_changes == 'true')
          id: check_existing_pr
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              EXISTING_PR=$(gh pr list \
                --head ${{ inputs.branch_name }} \
                --base ${{ inputs.pr_base_branch }} \
                --json number \
                --jq '.[0].number' 2>/dev/null || echo "")

              if [ -n "$EXISTING_PR" ]; then
                echo "existing_pr=$EXISTING_PR" >> $GITHUB_OUTPUT
                echo "üìã Found existing PR: #$EXISTING_PR"
              else
                echo "existing_pr=" >> $GITHUB_OUTPUT
                echo "‚ÑπÔ∏è  No existing PR found"
              fi

        - name: Create or update PR
          if: inputs.command == 'create-pr' && (inputs.pr_skip_if_no_changes == 'false' || steps.check_pr_changes.outputs.has_changes == 'true')
          id: create_pr
          shell: bash
          env:
              GH_TOKEN: ${{ inputs.github_token }}
          run: |
              # Simple variable substitution (basic support for ${variable})
              PR_TITLE="${{ inputs.pr_title }}"
              PR_TITLE="${PR_TITLE//\$\{branch_name\}/${{ inputs.branch_name }}}"
              PR_TITLE="${PR_TITLE//\$\{run_id\}/${{ github.run_id }}}"
              PR_TITLE="${PR_TITLE//\$\{repository\}/${{ github.repository }}}"

              PR_BODY="${{ inputs.pr_body }}"
              PR_BODY="${PR_BODY//\$\{branch_name\}/${{ inputs.branch_name }}}"
              PR_BODY="${PR_BODY//\$\{run_id\}/${{ github.run_id }}}"
              PR_BODY="${PR_BODY//\$\{repository\}/${{ github.repository }}}"
              PR_BODY="${PR_BODY//\$\{run_url\}/https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}}"

              EXISTING_PR="${{ steps.check_existing_pr.outputs.existing_pr }}"

              if [ -n "$EXISTING_PR" ]; then
                echo "pr_action=updated" >> $GITHUB_OUTPUT
                echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT

                # Use heredoc to prevent command injection from backticks in PR body
                gh pr edit $EXISTING_PR \
                  --title "$PR_TITLE" \
                  --body "$(cat <<'EOF'
              $PR_BODY
              EOF
              )" 2>/dev/null || true

                PR_URL=$(gh pr view $EXISTING_PR --json url --jq '.url')
                echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
                echo "pr_created=true" >> $GITHUB_OUTPUT
                echo "‚úÖ Updated PR #$EXISTING_PR: $PR_URL"
              else
                echo "pr_action=created" >> $GITHUB_OUTPUT

                # Use heredoc to prevent command injection from backticks in PR body
                PR_URL=$(gh pr create \
                  --base ${{ inputs.pr_base_branch }} \
                  --head ${{ inputs.branch_name }} \
                  --title "$PR_TITLE" \
                  --body "$(cat <<'EOF'
              $PR_BODY
              EOF
              )" \
                  --label "${{ inputs.pr_labels }}")

                PR_NUMBER=$(echo "$PR_URL" | grep -oP '\d+$')
                echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
                echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
                echo "pr_created=true" >> $GITHUB_OUTPUT
                echo "‚úÖ Created PR #$PR_NUMBER: $PR_URL"
              fi
